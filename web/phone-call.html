<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phone Call - LLMy Services</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #ff8a00 0%, #e52e71 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 2rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .return-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .return-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
        }

        .phone-interface {
            background: white;
            border-radius: 30px;
            padding: 40px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.25);
            text-align: center;
            position: relative;
            min-height: 600px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .phone-header {
            margin-bottom: 30px;
        }

        .phone-title {
            font-size: 2.5rem;
            color: #ff8a00;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .phone-subtitle {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 20px;
        }

        .call-status {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #ff8a00;
        }

        .status-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: #ff8a00;
            margin-bottom: 5px;
        }

        .status-details {
            font-size: 0.9rem;
            color: #666;
        }

        .call-timer {
            font-family: 'Courier New', monospace;
            font-size: 1.5rem;
            color: #333;
            margin: 10px 0;
        }

        /* Process Status Indicator */
        .process-status {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: none;
        }

        .process-status.active {
            display: block;
        }

        .process-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            text-align: center;
        }

        .process-stages {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .process-stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            position: relative;
        }

        .stage-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            margin-bottom: 5px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
        }

        .stage-icon.waiting {
            background: #e9ecef;
            color: #666;
        }

        .stage-icon.active {
            background: #ff8a00;
            color: white;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 0 0 rgba(255, 138, 0, 0.4);
        }

        .stage-icon.completed {
            background: #28a745;
            color: white;
        }

        .stage-icon.error {
            background: #dc3545;
            color: white;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 138, 0, 0.4);
            }
            70% {
                box-shadow: 0 0 0 6px rgba(255, 138, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 138, 0, 0);
            }
        }

        .stage-label {
            font-size: 0.7rem;
            color: #666;
            text-align: center;
            font-weight: 500;
            max-width: 60px;
            line-height: 1.2;
        }

        .stage-label.active {
            color: #ff8a00;
            font-weight: 600;
        }

        .stage-connector {
            position: absolute;
            top: 16px;
            left: 50%;
            right: -50%;
            height: 2px;
            background: #e9ecef;
            z-index: 1;
        }

        .stage-connector.active {
            background: #ff8a00;
        }

        .stage-connector.completed {
            background: #28a745;
        }

        .process-stage:last-child .stage-connector {
            display: none;
        }

        .process-details {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            min-height: 20px;
        }

        .agent-response-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 10px 0;
            padding: 8px;
            background: #f0f8ff;
            border-radius: 8px;
            border-left: 3px solid #007bff;
            display: none;
        }

        .agent-response-indicator.active {
            display: flex;
        }

        .response-dots {
            display: flex;
            gap: 3px;
        }

        .response-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #007bff;
            animation: typing 1.4s infinite;
        }

        .response-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .response-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.5;
            }
            30% {
                transform: translateY(-8px);
                opacity: 1;
            }
        }

        /* Audio Visualizer */
        .audio-visualizer {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: none;
            text-align: center;
        }

        .audio-visualizer.active {
            display: block;
        }

        .visualizer-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        .visualizer-container {
            position: relative;
            width: 100%;
            height: 80px;
            background: #f8f9fa;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-bars {
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 3px;
            height: 60px;
        }

        .audio-bar {
            width: 4px;
            background: linear-gradient(to top, #ff8a00, #e52e71);
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 2px;
            opacity: 0.3;
        }

        .audio-bar.active {
            opacity: 1;
            animation: audioWave 0.5s ease-in-out infinite alternate;
        }

        @keyframes audioWave {
            0% {
                transform: scaleY(0.3);
            }
            100% {
                transform: scaleY(1);
            }
        }

        .volume-indicator {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 0.8rem;
            color: #666;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 8px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .microphone-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
        }

        .mic-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #28a745;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.7rem;
        }

        .mic-icon.muted {
            background: #dc3545;
        }

        .visualizer-inactive {
            color: #999;
            font-size: 0.8rem;
            padding: 20px;
        }

        .phone-controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
        }

        .control-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .dial-button {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .dial-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 30px rgba(40, 167, 69, 0.4);
        }

        .hangup-button {
            background: linear-gradient(135deg, #dc3545 0%, #e91e63 100%);
            color: white;
        }

        .hangup-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 30px rgba(220, 53, 69, 0.4);
        }

        .interrupt-button {
            background: linear-gradient(135deg, #ffc107 0%, #ff8a00 100%);
            color: white;
        }

        .interrupt-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 30px rgba(255, 193, 7, 0.4);
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .settings-panel {
            background: white;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.15);
            height: fit-content;
        }

        .settings-title {
            font-size: 1.4rem;
            color: #333;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            display: block;
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .setting-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .setting-input:focus {
            outline: none;
            border-color: #ff8a00;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #ff8a00;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .call-history {
            margin-top: 30px;
        }

        .history-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 3px solid #ff8a00;
        }

        .history-time {
            font-size: 0.8rem;
            color: #666;
        }

        .history-duration {
            font-size: 0.9rem;
            color: #333;
            font-weight: 500;
        }

        .conversation-display {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
        }

        .message {
            margin: 10px 0;
        }

        .user-message {
            color: #0066cc;
            font-weight: 500;
        }

        .ai-message {
            color: #ff8a00;
            font-weight: 500;
        }

        .loading-indicator {
            display: none;
            margin: 20px 0;
        }

        .loading-dots {
            display: inline-block;
            position: relative;
            width: 80px;
            height: 80px;
        }

        .loading-dots div {
            position: absolute;
            top: 33px;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: #ff8a00;
            animation-timing-function: cubic-bezier(0, 1, 1, 0);
        }

        .loading-dots div:nth-child(1) {
            left: 8px;
            animation: loading1 0.6s infinite;
        }

        .loading-dots div:nth-child(2) {
            left: 8px;
            animation: loading2 0.6s infinite;
        }

        .loading-dots div:nth-child(3) {
            left: 32px;
            animation: loading2 0.6s infinite;
        }

        .loading-dots div:nth-child(4) {
            left: 56px;
            animation: loading3 0.6s infinite;
        }

        @keyframes loading1 {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }

        @keyframes loading3 {
            0% { transform: scale(1); }
            100% { transform: scale(0); }
        }

        @keyframes loading2 {
            0% { transform: translate(0, 0); }
            100% { transform: translate(24px, 0); }
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .phone-interface {
                padding: 30px 20px;
            }
            
            .phone-title {
                font-size: 2rem;
            }
            
            .control-button {
                width: 70px;
                height: 70px;
                font-size: 1.5rem;
            }
            
            .phone-controls {
                gap: 20px;
            }
        }

        /* Status-specific styles */
        .status-idle .status-text { color: #6c757d; }
        .status-dialing .status-text { color: #ffc107; }
        .status-connected .status-text { color: #28a745; }
        .status-ended .status-text { color: #dc3545; }

        /* Animation for ringing */
        .status-dialing .phone-interface {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">üìû Phone Call</div>
            <a href="/" class="return-btn">
                ‚Üê Back to Services
            </a>
        </div>
    </div>

    <div class="container">
        <div class="phone-interface">
            <div class="phone-header">
                <h1 class="phone-title">AI Phone Call</h1>
                <p class="phone-subtitle">Have a natural conversation with AI, just like a real phone call!</p>
            </div>

            <div class="call-status status-idle" id="callStatus">
                <div class="status-text" id="statusText">Ready to dial</div>
                <div class="status-details" id="statusDetails">Click the dial button to start your call</div>
                <div class="call-timer" id="callTimer">00:00</div>
            </div>

            <!-- Process Status Indicator -->
            <div class="process-status" id="processStatus">
                <div class="process-title">Processing Status</div>
                <div class="process-stages">
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-listening">üé§</div>
                        <div class="stage-label">Listening</div>
                        <div class="stage-connector"></div>
                    </div>
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-stt">üó£Ô∏è</div>
                        <div class="stage-label">Speech Recognition</div>
                        <div class="stage-connector"></div>
                    </div>
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-transfer">üì§</div>
                        <div class="stage-label">Transfer</div>
                        <div class="stage-connector"></div>
                    </div>
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-llm">üß†</div>
                        <div class="stage-label">AI Thinking</div>
                        <div class="stage-connector"></div>
                    </div>
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-tts">üîä</div>
                        <div class="stage-label">Text to Speech</div>
                    </div>
                </div>
                <div class="process-details" id="processDetails">Ready to process audio</div>
                
                <!-- Agent Response Indicator -->
                <div class="agent-response-indicator" id="agentResponseIndicator">
                    <div class="response-dots">
                        <div class="response-dot"></div>
                        <div class="response-dot"></div>
                        <div class="response-dot"></div>
                    </div>
                    <span>Agent is responding...</span>
                </div>
            </div>

            <!-- Audio Visualizer -->
            <div class="audio-visualizer" id="audioVisualizer">
                <div class="visualizer-title">üé§ Audio Input</div>
                <div class="visualizer-container">
                    <div class="audio-bars" id="audioBars">
                        <!-- Audio bars will be generated by JavaScript -->
                    </div>
                    <div class="volume-indicator" id="volumeIndicator">0%</div>
                </div>
                <div class="microphone-status">
                    <div class="mic-icon" id="micIcon">üé§</div>
                    <span id="micStatus">Microphone Ready</span>
                </div>
            </div>

            <div class="conversation-display" id="conversationDisplay" style="display: none;">
                <div id="conversationMessages"></div>
            </div>

            <div class="loading-indicator" id="loadingIndicator">
                <div class="loading-dots">
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                </div>
                <p>AI is thinking...</p>
            </div>

            <div class="phone-controls">
                <button class="control-button dial-button" id="dialButton" title="Start Call">
                    üìû
                </button>
                <button class="control-button interrupt-button" id="interruptButton" title="Interrupt AI" disabled>
                    ‚è∏Ô∏è
                </button>
                <button class="control-button hangup-button" id="hangupButton" title="End Call" disabled>
                    üìµ
                </button>
            </div>
        </div>

        <div class="settings-panel">
            <h3 class="settings-title">Call Settings</h3>
            
            <div class="setting-group">
                <label class="setting-label">Language</label>
                <select class="setting-input" id="languageSelect">
                    <option value="en">English</option>
                    <option value="zh">‰∏≠Êñá (Chinese)</option>
                </select>
            </div>

            <div class="setting-group">
                <label class="setting-label">AI Model</label>
                <select class="setting-input" id="modelSelect">
                    <option value="gemma2:2b">Gemma 2 2B (Fastest)</option>
                    <option value="gemma3:latest">Gemma 3 (Balanced)</option>
                    <option value="llama3.1:8b">Llama 3.1 8B (Quality)</option>
                    <option value="phi3.5:latest">Phi 3.5 (Advanced)</option>
                </select>
            </div>

            <div class="setting-group">
                <label class="setting-label">Voice Speed</label>
                <select class="setting-input" id="speedSelect">
                    <option value="0.8">Slow</option>
                    <option value="1.0" selected>Normal</option>
                    <option value="1.2">Fast</option>
                </select>
            </div>

            <div class="setting-group">
                <label class="setting-label">
                    Kid-Friendly Mode
                    <label class="toggle-switch">
                        <input type="checkbox" id="kidFriendlyToggle">
                        <span class="slider"></span>
                    </label>
                </label>
            </div>

            <div class="setting-group">
                <label class="setting-label">
                    Background Music
                    <label class="toggle-switch">
                        <input type="checkbox" id="backgroundMusicToggle" checked>
                        <span class="slider"></span>
                    </label>
                </label>
            </div>

            <div class="call-history">
                <h4 class="settings-title">Recent Calls</h4>
                <div id="callHistoryList">
                    <div class="history-item">
                        <div class="history-time">Today, 2:30 PM</div>
                        <div class="history-duration">Duration: 03:45</div>
                    </div>
                    <div class="history-item">
                        <div class="history-time">Yesterday, 10:15 AM</div>
                        <div class="history-duration">Duration: 01:22</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PhoneCallInterface {
            constructor() {
                this.callState = 'idle'; // idle, dialing, connected, ended
                this.callTimer = null;
                this.heartbeatInterval = null;  // Add heartbeat mechanism
                this.callStartTime = null;
                this.currentSessionId = null;
                this.websocket = null;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.currentAudio = null; // Track current AI audio for interrupts
                this.backgroundAudio = null; // Track background music
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupAudioPermissions();
            }

            initializeElements() {
                this.dialButton = document.getElementById('dialButton');
                this.hangupButton = document.getElementById('hangupButton');
                this.interruptButton = document.getElementById('interruptButton');
                this.statusText = document.getElementById('statusText');
                this.statusDetails = document.getElementById('statusDetails');
                this.callTimerDisplay = document.getElementById('callTimer');
                this.conversationDisplay = document.getElementById('conversationDisplay');
                this.conversationMessages = document.getElementById('conversationMessages');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                this.callStatus = document.getElementById('callStatus');
                
                // Process status elements
                this.processStatus = document.getElementById('processStatus');
                this.processDetails = document.getElementById('processDetails');
                this.agentResponseIndicator = document.getElementById('agentResponseIndicator');
                
                // Audio visualizer elements
                this.audioVisualizer = document.getElementById('audioVisualizer');
                this.audioBars = document.getElementById('audioBars');
                this.volumeIndicator = document.getElementById('volumeIndicator');
                this.micIcon = document.getElementById('micIcon');
                this.micStatus = document.getElementById('micStatus');
                
                // Stage elements
                this.stageElements = {
                    listening: document.getElementById('stage-listening'),
                    stt: document.getElementById('stage-stt'),
                    transfer: document.getElementById('stage-transfer'),
                    llm: document.getElementById('stage-llm'),
                    tts: document.getElementById('stage-tts')
                };
                
                // Audio analysis
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.animationFrame = null;
                
                // Initialize audio bars
                this.initializeAudioBars();
                
                // Settings
                this.languageSelect = document.getElementById('languageSelect');
                this.modelSelect = document.getElementById('modelSelect');
                this.speedSelect = document.getElementById('speedSelect');
                this.kidFriendlyToggle = document.getElementById('kidFriendlyToggle');
                this.backgroundMusicToggle = document.getElementById('backgroundMusicToggle');
            }

            // Process Status Management
            showProcessStatus() {
                this.processStatus.classList.add('active');
                this.resetProcessStages();
            }

            hideProcessStatus() {
                this.processStatus.classList.remove('active');
                this.agentResponseIndicator.classList.remove('active');
            }

            resetProcessStages() {
                Object.values(this.stageElements).forEach(element => {
                    element.className = 'stage-icon waiting';
                });
                this.updateProcessDetails('Ready to process audio');
                this.agentResponseIndicator.classList.remove('active');
            }

            setStageStatus(stageName, status, details = '') {
                const element = this.stageElements[stageName];
                if (!element) return;

                // Reset all stage classes
                element.className = 'stage-icon';
                
                switch (status) {
                    case 'active':
                        element.classList.add('active');
                        this.updateProcessDetails(details || `${this.getStageName(stageName)} in progress...`);
                        break;
                    case 'completed':
                        element.classList.add('completed');
                        break;
                    case 'error':
                        element.classList.add('error');
                        this.updateProcessDetails(details || `Error in ${this.getStageName(stageName)}`);
                        break;
                    default:
                        element.classList.add('waiting');
                }
            }

            getStageName(stageKey) {
                const stageNames = {
                    listening: 'Audio Capture',
                    stt: 'Speech Recognition',
                    transfer: 'Data Transfer',
                    llm: 'AI Processing',
                    tts: 'Speech Synthesis'
                };
                return stageNames[stageKey] || stageKey;
            }

            updateProcessDetails(message) {
                if (this.processDetails) {
                    this.processDetails.textContent = message;
                }
            }

            showAgentResponse() {
                this.agentResponseIndicator.classList.add('active');
            }

            hideAgentResponse() {
                this.agentResponseIndicator.classList.remove('active');
            }

            // Process flow management
            startProcessFlow() {
                this.showProcessStatus();
                this.setStageStatus('listening', 'active', 'Capturing audio...');
            }

            completeListening() {
                this.setStageStatus('listening', 'completed');
                this.setStageStatus('stt', 'active', 'Converting speech to text...');
            }

            completeSpeechRecognition(transcription = '') {
                this.setStageStatus('stt', 'completed');
                this.setStageStatus('transfer', 'active', 'Sending data to server...');
                if (transcription) {
                    this.updateProcessDetails(`Recognized: "${transcription}"`);
                }
            }

            completeTransfer() {
                this.setStageStatus('transfer', 'completed');
                this.setStageStatus('llm', 'active', 'AI is thinking...');
                this.showAgentResponse();
            }

            completeLLMProcessing() {
                this.setStageStatus('llm', 'completed');
                this.setStageStatus('tts', 'active', 'Generating speech...');
                this.hideAgentResponse();
            }

            completeTTSProcessing() {
                this.setStageStatus('tts', 'completed');
                this.updateProcessDetails('Response ready - playing audio');
                
                // Reset after a short delay
                setTimeout(() => {
                    this.resetProcessStages();
                }, 2000);
            }

            handleProcessError(stage, error) {
                this.setStageStatus(stage, 'error', `Error: ${error}`);
                this.hideAgentResponse();
                
                // Reset after error display
                setTimeout(() => {
                    this.resetProcessStages();
                }, 3000);
            }

            // Audio Visualizer Methods
            initializeAudioBars() {
                // Create 20 audio bars
                const numBars = 20;
                this.audioBars.innerHTML = '';
                
                for (let i = 0; i < numBars; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    bar.style.height = '2px';
                    this.audioBars.appendChild(bar);
                }
            }

            showAudioVisualizer() {
                this.audioVisualizer.classList.add('active');
            }

            hideAudioVisualizer() {
                this.audioVisualizer.classList.remove('active');
                this.stopAudioVisualization();
            }

            async setupAudioVisualization(stream) {
                try {
                    // Create audio context and analyser
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    
                    // Configure analyser
                    this.analyser.fftSize = 64; // Lower value for simpler visualization
                    this.analyser.smoothingTimeConstant = 0.8;
                    
                    // Connect microphone stream to analyser
                    const source = this.audioContext.createMediaStreamSource(stream);
                    source.connect(this.analyser);
                    
                    // Create data array for frequency data
                    const bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(bufferLength);
                    
                    // Start visualization
                    this.startAudioVisualization();
                    
                    this.updateMicrophoneStatus('active', 'Recording audio...');
                    
                } catch (error) {
                    console.error('Failed to setup audio visualization:', error);
                    this.updateMicrophoneStatus('error', 'Visualization unavailable');
                }
            }

            startAudioVisualization() {
                if (!this.analyser || !this.dataArray) return;
                
                const visualize = () => {
                    this.animationFrame = requestAnimationFrame(visualize);
                    
                    // Get frequency data
                    this.analyser.getByteFrequencyData(this.dataArray);
                    
                    // Calculate average volume
                    let sum = 0;
                    for (let i = 0; i < this.dataArray.length; i++) {
                        sum += this.dataArray[i];
                    }
                    const average = sum / this.dataArray.length;
                    const volumePercent = Math.round((average / 255) * 100);
                    
                    // Update volume indicator
                    this.volumeIndicator.textContent = `${volumePercent}%`;
                    
                    // Update audio bars
                    const bars = this.audioBars.children;
                    const dataStep = this.dataArray.length / bars.length;
                    
                    for (let i = 0; i < bars.length; i++) {
                        const dataIndex = Math.floor(i * dataStep);
                        const value = this.dataArray[dataIndex];
                        const height = Math.max(2, (value / 255) * 60); // Min 2px, max 60px
                        
                        bars[i].style.height = `${height}px`;
                        
                        // Add active class for bars with significant activity
                        if (value > 30) {
                            bars[i].classList.add('active');
                        } else {
                            bars[i].classList.remove('active');
                        }
                    }
                    
                    // Update microphone status based on activity
                    if (average > 10) {
                        this.updateMicrophoneStatus('active', 'Detecting audio...');
                    } else {
                        this.updateMicrophoneStatus('idle', 'Listening...');
                    }
                };
                
                visualize();
            }

            stopAudioVisualization() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                
                // Reset bars
                const bars = this.audioBars.children;
                for (let bar of bars) {
                    bar.style.height = '2px';
                    bar.classList.remove('active');
                }
                
                // Reset volume indicator
                this.volumeIndicator.textContent = '0%';
                
                this.updateMicrophoneStatus('inactive', 'Microphone inactive');
            }

            updateMicrophoneStatus(status, message) {
                this.micStatus.textContent = message;
                
                // Update microphone icon
                switch (status) {
                    case 'active':
                        this.micIcon.style.background = '#28a745';
                        this.micIcon.textContent = 'üé§';
                        this.micIcon.classList.remove('muted');
                        break;
                    case 'idle':
                        this.micIcon.style.background = '#ffc107';
                        this.micIcon.textContent = 'üé§';
                        this.micIcon.classList.remove('muted');
                        break;
                    case 'processing':
                        this.micIcon.style.background = '#007bff';
                        this.micIcon.textContent = '‚ö°';
                        this.micIcon.classList.remove('muted');
                        break;
                    case 'inactive':
                    case 'error':
                        this.micIcon.style.background = '#dc3545';
                        this.micIcon.textContent = 'üö´';
                        this.micIcon.classList.add('muted');
                        break;
                }
            }

            setupEventListeners() {
                this.dialButton.addEventListener('click', () => this.startCall());
                this.hangupButton.addEventListener('click', () => this.endCall());
                this.interruptButton.addEventListener('click', () => this.interruptAI());
                
                // Settings change handlers
                this.languageSelect.addEventListener('change', () => this.updateSettings());
                this.modelSelect.addEventListener('change', () => this.updateSettings());
                this.speedSelect.addEventListener('change', () => this.updateSettings());
                this.kidFriendlyToggle.addEventListener('change', () => this.updateSettings());
                this.backgroundMusicToggle.addEventListener('change', () => this.updateSettings());
            }

            async setupAudioPermissions() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());
                    console.log('Audio permissions granted');
                } catch (error) {
                    console.error('Audio permissions denied:', error);
                    this.updateStatus('error', 'Microphone access required for phone calls');
                }
            }

            async startCall() {
                try {
                    this.updateCallState('dialing');
                    this.currentSessionId = this.generateSessionId();
                    
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Setup WebSocket connection
                    await this.setupWebSocket();
                    
                    // Setup audio visualization
                    await this.setupAudioVisualization(stream);
                    
                    // Start audio recording
                    this.setupAudioRecording(stream);
                    
                    this.updateCallState('connected');
                    this.startCallTimer();
                    
                    // Show process status indicator and audio visualizer
                    this.showProcessStatus();
                    this.showAudioVisualizer();
                    
                    this.conversationDisplay.style.display = 'block';
                    this.addMessage('system', 'Call connected! Start speaking...');
                    
                } catch (error) {
                    console.error('Failed to start call:', error);
                    this.updateStatus('error', 'Failed to start call: ' + error.message);
                    this.updateCallState('idle');
                    this.hideProcessStatus();
                    this.hideAudioVisualizer();
                }
            }

            async setupWebSocket() {
                return new Promise((resolve, reject) => {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/api/phone/stream`;
                    
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('WebSocket connected');
                        this.websocket.send(JSON.stringify({
                            type: 'session_start',
                            session_id: this.currentSessionId,
                            settings: this.getCallSettings()
                        }));
                        resolve();
                    };
                    
                    this.websocket.onmessage = (event) => {
                        this.handleWebSocketMessage(JSON.parse(event.data));
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        reject(error);
                    };
                    
                    this.websocket.onclose = () => {
                        console.log('WebSocket disconnected');
                        if (this.callState === 'connected') {
                            this.endCall();
                        }
                    };
                });
            }

            setupAudioRecording(stream) {
                this.mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.audioChunks.push(event.data);
                    }
                };

                this.mediaRecorder.onstop = () => {
                    if (this.audioChunks.length > 0) {
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                        this.sendAudioData(audioBlob);
                        this.audioChunks = [];
                    }
                };

                // Record in shorter chunks for more responsive processing
                this.mediaRecorder.start();
                this.recordingInterval = setInterval(() => {
                    if (this.mediaRecorder.state === 'recording') {
                        this.mediaRecorder.stop();
                        this.mediaRecorder.start();
                    }
                }, 2000); // Send audio every 2 seconds for better responsiveness
            }

            sendAudioData(audioBlob) {
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    // Start the process flow
                    this.startProcessFlow();
                    
                    const reader = new FileReader();
                    reader.onload = () => {
                        // Complete listening stage and move to transfer
                        this.completeListening();
                        
                        const audioData = reader.result.split(',')[1]; // Remove data URL prefix
                        this.websocket.send(JSON.stringify({
                            type: 'audio_data',
                            session_id: this.currentSessionId,
                            audio: audioData,
                            timestamp: Date.now()
                        }));
                    };
                    reader.readAsDataURL(audioBlob);
                }
            }

            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'process_status':
                        // Handle process status updates
                        if (data.stage && data.status) {
                            this.setStageStatus(data.stage, data.status, data.details);
                        }
                        break;
                        
                    case 'transcription':
                        this.completeSpeechRecognition(data.text);
                        this.completeTransfer();
                        this.addMessage('user', data.text);
                        this.showLoading(true);
                        
                        // Temporarily pause audio visualization during processing
                        this.updateMicrophoneStatus('processing', 'Processing speech...');
                        
                        if (data.processing_time) {
                            console.log(`STT processing time: ${data.processing_time.toFixed(2)}s`);
                        }
                        break;
                        
                    case 'ai_response':
                        this.completeLLMProcessing();
                        this.completeTTSProcessing();
                        this.showLoading(false);
                        this.addMessage('ai', data.text);
                        
                        // Resume normal microphone status
                        this.updateMicrophoneStatus('idle', 'Listening...');
                        
                        if (data.audio) {
                            this.playAudioResponse(data.audio);
                        }
                        if (data.timing) {
                            console.log(`AI processing times:`, data.timing);
                        }
                        break;
                        
                    case 'ai_message':
                        // Phase 3: Handle AI messages (like kid-friendly greetings)
                        this.addMessage('ai', data.message);
                        break;
                        
                    case 'background_music':
                        if (this.getCallSettings().background_music) {
                            this.playBackgroundMusic(data.audio, data.volume || 0.3);
                        }
                        break;
                        
                    case 'interrupt':
                    case 'interrupt_confirmed':
                        // Phase 3: Handle interrupt confirmations
                        this.stopCurrentAudio();
                        this.stopBackgroundMusic();
                        this.showLoading(false);
                        this.updateStatus('success', data.message || 'AI interrupted');
                        this.resetProcessStages();
                        break;
                        
                    case 'session_ended':
                        // Phase 3: Handle enhanced session end with summary
                        this.showLoading(false);
                        this.hideProcessStatus();
                        if (data.call_summary) {
                            this.addMessage('system', 
                                `Call ended. Duration: ${data.call_summary.duration}, Messages: ${data.call_summary.messages_exchanged}`
                            );
                        }
                        this.updateStatus('success', data.message);
                        break;
                        
                    case 'error':
                        this.showLoading(false);
                        // Handle process errors based on context
                        if (data.stage) {
                            this.handleProcessError(data.stage, data.message);
                        } else {
                            this.resetProcessStages();
                        }
                        this.addMessage('system', 'Error: ' + data.message);
                        break;
                        
                    case 'status':
                        this.updateStatus('info', data.message);
                        // Phase 3: Handle kid-friendly mode confirmation
                        if (data.kid_friendly_mode !== undefined) {
                            const toggle = document.getElementById('kidFriendlyToggle');
                            if (toggle) {
                                toggle.checked = data.kid_friendly_mode;
                            }
                            if (data.kid_friendly_mode) {
                                this.addMessage('system', 'üë∂ Kid-friendly mode enabled');
                            }
                        }
                        break;
                }
            }

            playAudioResponse(audioBase64) {
                try {
                    // Stop any existing background music
                    this.stopBackgroundMusic();
                    
                    const audio = new Audio('data:audio/wav;base64,' + audioBase64);
                    audio.volume = 1.0; // Full volume for AI response
                    
                    audio.play().catch(error => {
                        console.error('Failed to play AI audio response:', error);
                        this.addMessage('system', 'Audio playback failed - check browser permissions');
                    });
                    
                    // Track current audio for interrupt functionality
                    this.currentAudio = audio;
                    
                    audio.onended = () => {
                        this.currentAudio = null;
                    };
                } catch (error) {
                    console.error('Error creating audio element:', error);
                }
            }

            playBackgroundMusic(audioBase64, volume = 0.3) {
                try {
                    // Stop any existing background music
                    this.stopBackgroundMusic();
                    
                    const audio = new Audio('data:audio/wav;base64,' + audioBase64);
                    audio.volume = volume;
                    audio.loop = true; // Loop background music
                    
                    audio.play().catch(error => {
                        console.log('Background music playback failed (this is normal):', error);
                    });
                    
                    this.backgroundAudio = audio;
                } catch (error) {
                    console.log('Background music error (this is normal):', error);
                }
            }

            stopBackgroundMusic() {
                if (this.backgroundAudio) {
                    this.backgroundAudio.pause();
                    this.backgroundAudio.currentTime = 0;
                    this.backgroundAudio = null;
                }
            }

            // Phase 3: Stop current AI audio (for interrupts)
            stopCurrentAudio() {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                    this.currentAudio = null;
                }
            }

            endCall() {
                this.updateCallState('ended');
                
                // Hide process status and audio visualizer
                this.hideProcessStatus();
                this.hideAudioVisualizer();
                
                // Clean up resources
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                }
                
                if (this.recordingInterval) {
                    clearInterval(this.recordingInterval);
                }
                
                // Close audio context
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                if (this.websocket) {
                    this.websocket.send(JSON.stringify({
                        type: 'session_end',
                        session_id: this.currentSessionId
                    }));
                    this.websocket.close();
                }
                
                this.stopCallTimer();
                
                // Reset UI after a delay
                setTimeout(() => {
                    this.updateCallState('idle');
                    this.conversationDisplay.style.display = 'none';
                    this.conversationMessages.innerHTML = '';
                }, 3000);
                
                this.saveCallToHistory();
            }

            interruptAI() {
                // Stop current AI audio playback
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                    this.currentAudio = null;
                }
                
                // Stop background music
                this.stopBackgroundMusic();
                
                // Send interrupt signal to server
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify({
                        type: 'interrupt',
                        session_id: this.currentSessionId
                    }));
                }
                
                this.showLoading(false);
                this.addMessage('system', 'AI interrupted by user');
            }

            updateCallState(newState) {
                this.callState = newState;
                
                // Update button states
                this.dialButton.disabled = newState !== 'idle';
                this.hangupButton.disabled = newState === 'idle';
                this.interruptButton.disabled = newState !== 'connected';
                
                // Update status display
                this.callStatus.className = `call-status status-${newState}`;
                
                switch (newState) {
                    case 'idle':
                        this.updateStatus('info', 'Ready to dial', 'Click the dial button to start your call');
                        break;
                    case 'dialing':
                        this.updateStatus('warning', 'Dialing...', 'Connecting to AI assistant');
                        break;
                    case 'connected':
                        this.updateStatus('success', 'Connected', 'Call in progress');
                        break;
                    case 'ended':
                        this.updateStatus('info', 'Call ended', 'Thank you for calling!');
                        break;
                }
            }

            updateStatus(type, text, details = '') {
                this.statusText.textContent = text;
                this.statusDetails.textContent = details;
            }

            addMessage(type, text) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}-message`;
                
                const timestamp = new Date().toLocaleTimeString();
                const prefix = type === 'user' ? 'You' : type === 'ai' ? 'AI' : 'System';
                
                messageDiv.innerHTML = `<strong>${prefix} (${timestamp}):</strong> ${text}`;
                this.conversationMessages.appendChild(messageDiv);
                this.conversationMessages.scrollTop = this.conversationMessages.scrollHeight;
            }

            showLoading(show) {
                this.loadingIndicator.style.display = show ? 'block' : 'none';
            }

            startCallTimer() {
                this.callStartTime = Date.now();
                this.callTimer = setInterval(() => {
                    const elapsed = Date.now() - this.callStartTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    this.callTimerDisplay.textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
                
                // Start WebSocket heartbeat to prevent disconnections
                this.startHeartbeat();
            }

            stopCallTimer() {
                if (this.callTimer) {
                    clearInterval(this.callTimer);
                    this.callTimer = null;
                }
                
                // Stop WebSocket heartbeat
                this.stopHeartbeat();
            }
            
            startHeartbeat() {
                // Send ping every 10 seconds to keep connection alive
                this.heartbeatInterval = setInterval(() => {
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.websocket.send(JSON.stringify({
                            type: 'ping',
                            session_id: this.currentSessionId,
                            timestamp: Date.now()
                        }));
                    }
                }, 10000); // 10 second intervals
            }
            
            stopHeartbeat() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
            }

            getCallSettings() {
                // Ensure all values have proper defaults
                const speed = parseFloat(this.speedSelect.value);
                return {
                    language: this.languageSelect.value || 'en',
                    model: this.modelSelect.value || 'gemma2:2b',
                    speed: isNaN(speed) ? 1.0 : speed,
                    kid_friendly: Boolean(this.kidFriendlyToggle.checked),
                    background_music: Boolean(this.backgroundMusicToggle.checked)
                };
            }

            updateSettings() {
                // Save settings to localStorage
                localStorage.setItem('phoneCallSettings', JSON.stringify(this.getCallSettings()));
                
                // If call is active, send settings update
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify({
                        type: 'settings_update',
                        session_id: this.currentSessionId,
                        settings: this.getCallSettings()
                    }));
                }
            }

            generateSessionId() {
                return 'phone-call-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            }

            saveCallToHistory() {
                const callDuration = this.callTimerDisplay.textContent;
                const historyItem = {
                    timestamp: new Date().toISOString(),
                    duration: callDuration,
                    settings: this.getCallSettings()
                };
                
                // Save to localStorage (in real app, this would go to backend)
                const history = JSON.parse(localStorage.getItem('callHistory') || '[]');
                history.unshift(historyItem);
                history.splice(10); // Keep only last 10 calls
                localStorage.setItem('callHistory', JSON.stringify(history));
                
                this.updateCallHistoryDisplay();
            }

            updateCallHistoryDisplay() {
                const history = JSON.parse(localStorage.getItem('callHistory') || '[]');
                const historyList = document.getElementById('callHistoryList');
                
                historyList.innerHTML = history.map(call => `
                    <div class="history-item">
                        <div class="history-time">${new Date(call.timestamp).toLocaleString()}</div>
                        <div class="history-duration">Duration: ${call.duration}</div>
                    </div>
                `).join('');
            }

            loadSettings() {
                const saved = localStorage.getItem('phoneCallSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    this.languageSelect.value = settings.language || 'en';
                    this.modelSelect.value = settings.model || 'gemma2:2b';
                    this.speedSelect.value = settings.speed || 1.0;
                    this.kidFriendlyToggle.checked = settings.kid_friendly || false;
                    this.backgroundMusicToggle.checked = settings.background_music !== false;
                }
            }
        }

        // Initialize the phone call interface when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const phoneInterface = new PhoneCallInterface();
            phoneInterface.loadSettings();
            phoneInterface.updateCallHistoryDisplay();
        });
    </script>
</body>
</html>
