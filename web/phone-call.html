<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phone Call - LLMy Services</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #ff8a00 0%, #e52e71 100%);
            min-height: 100vh;
            color: #333;
            overflow-x: hidden;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 20px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 2rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .return-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .return-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
        }

        .phone-interface {
            background: white;
            border-radius: 30px;
            padding: 40px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.25);
            text-align: center;
            position: relative;
            min-height: 600px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .phone-header {
            margin-bottom: 30px;
        }

        .phone-title {
            font-size: 2.5rem;
            color: #ff8a00;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .phone-subtitle {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 20px;
        }

        .call-status {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #ff8a00;
        }

        .status-text {
            font-size: 1.2rem;
            font-weight: 600;
            color: #ff8a00;
            margin-bottom: 5px;
        }

        .status-details {
            font-size: 0.9rem;
            color: #666;
        }

        .call-timer {
            font-family: 'Courier New', monospace;
            font-size: 1.5rem;
            color: #333;
            margin: 10px 0;
        }

        /* Process Status Indicator */
        .process-status {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: none;
        }

        .process-status.active {
            display: block;
        }

        .process-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            text-align: center;
        }

        .process-stages {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .process-stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
            position: relative;
        }

        .stage-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            margin-bottom: 5px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 2;
        }

        .stage-icon.waiting {
            background: #e9ecef;
            color: #666;
        }

        .stage-icon.active {
            background: #ff8a00;
            color: white;
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 0 0 rgba(255, 138, 0, 0.4);
        }

        .stage-icon.completed {
            background: #28a745;
            color: white;
        }

        .stage-icon.error {
            background: #dc3545;
            color: white;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 138, 0, 0.4);
            }
            70% {
                box-shadow: 0 0 0 6px rgba(255, 138, 0, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(255, 138, 0, 0);
            }
        }

        .stage-label {
            font-size: 0.7rem;
            color: #666;
            text-align: center;
            font-weight: 500;
            max-width: 60px;
            line-height: 1.2;
        }

        .stage-label.active {
            color: #ff8a00;
            font-weight: 600;
        }

        .stage-connector {
            position: absolute;
            top: 16px;
            left: 50%;
            right: -50%;
            height: 2px;
            background: #e9ecef;
            z-index: 1;
        }

        .stage-connector.active {
            background: #ff8a00;
        }

        .stage-connector.completed {
            background: #28a745;
        }

        .process-stage:last-child .stage-connector {
            display: none;
        }

        .process-details {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            min-height: 20px;
        }

        .agent-response-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin: 10px 0;
            padding: 8px;
            background: #f0f8ff;
            border-radius: 8px;
            border-left: 3px solid #007bff;
            display: none;
        }

        .agent-response-indicator.active {
            display: flex;
        }

        .response-dots {
            display: flex;
            gap: 3px;
        }

        .response-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #007bff;
            animation: typing 1.4s infinite;
        }

        .response-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .response-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.5;
            }
            30% {
                transform: translateY(-8px);
                opacity: 1;
            }
        }

        /* Audio Visualizer */
        .audio-visualizer {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: none;
            text-align: center;
        }

        .audio-visualizer.active {
            display: block;
        }

        .visualizer-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        .visualizer-container {
            position: relative;
            width: 100%;
            height: 80px;
            background: #f8f9fa;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-bars {
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 3px;
            height: 60px;
        }

        .audio-bar {
            width: 4px;
            background: linear-gradient(to top, #ff8a00, #e52e71);
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 2px;
            opacity: 0.3;
        }

        .audio-bar.active {
            opacity: 1;
            animation: audioWave 0.5s ease-in-out infinite alternate;
        }

        @keyframes audioWave {
            0% {
                transform: scaleY(0.3);
            }
            100% {
                transform: scaleY(1);
            }
        }

        .volume-indicator {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 0.8rem;
            color: #666;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 8px;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .microphone-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #666;
        }

        .mic-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #28a745;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.7rem;
        }

        .mic-icon.muted {
            background: #dc3545;
        }

        .visualizer-inactive {
            color: #999;
            font-size: 0.8rem;
            padding: 20px;
        }

        .phone-controls {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 30px 0;
        }

        .control-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .dial-button {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .dial-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 30px rgba(40, 167, 69, 0.4);
        }

        .hangup-button {
            background: linear-gradient(135deg, #dc3545 0%, #e91e63 100%);
            color: white;
        }

        .hangup-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 30px rgba(220, 53, 69, 0.4);
        }

        .interrupt-button {
            background: linear-gradient(135deg, #ffc107 0%, #ff8a00 100%);
            color: white;
        }

        .interrupt-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 30px rgba(255, 193, 7, 0.4);
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .settings-panel {
            background: white;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.15);
            height: fit-content;
        }

        .settings-title {
            font-size: 1.4rem;
            color: #333;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-label {
            display: block;
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .setting-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .setting-input:focus {
            outline: none;
            border-color: #ff8a00;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #ff8a00;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .call-history {
            margin-top: 30px;
        }

        .history-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 3px solid #ff8a00;
        }

        .history-time {
            font-size: 0.8rem;
            color: #666;
        }

        .history-duration {
            font-size: 0.9rem;
            color: #333;
            font-weight: 500;
        }

        .conversation-display {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
        }

        .message {
            margin: 10px 0;
        }

        .user-message {
            color: #0066cc;
            font-weight: 500;
        }

        .ai-message {
            color: #ff8a00;
            font-weight: 500;
        }

        .loading-indicator {
            display: none;
            margin: 20px 0;
        }

        .loading-dots {
            display: inline-block;
            position: relative;
            width: 80px;
            height: 80px;
        }

        .loading-dots div {
            position: absolute;
            top: 33px;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: #ff8a00;
            animation-timing-function: cubic-bezier(0, 1, 1, 0);
        }

        .loading-dots div:nth-child(1) {
            left: 8px;
            animation: loading1 0.6s infinite;
        }

        .loading-dots div:nth-child(2) {
            left: 8px;
            animation: loading2 0.6s infinite;
        }

        .loading-dots div:nth-child(3) {
            left: 32px;
            animation: loading2 0.6s infinite;
        }

        .loading-dots div:nth-child(4) {
            left: 56px;
            animation: loading3 0.6s infinite;
        }

        @keyframes loading1 {
            0% { transform: scale(0); }
            100% { transform: scale(1); }
        }

        @keyframes loading3 {
            0% { transform: scale(1); }
            100% { transform: scale(0); }
        }

        @keyframes loading2 {
            0% { transform: translate(0, 0); }
            100% { transform: translate(24px, 0); }
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .phone-interface {
                padding: 30px 20px;
            }
            
            .phone-title {
                font-size: 2rem;
            }
            
            .control-button {
                width: 70px;
                height: 70px;
                font-size: 1.5rem;
            }
            
            .phone-controls {
                gap: 20px;
            }
        }

        /* Status-specific styles */
        .status-idle .status-text { color: #6c757d; }
        .status-dialing .status-text { color: #ffc107; }
        .status-connected .status-text { color: #28a745; }
        .status-ended .status-text { color: #dc3545; }

        /* Animation for ringing */
        .status-dialing .phone-interface {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">üìû Phone Call</div>
            <a href="/" class="return-btn">
                ‚Üê Back to Services
            </a>
        </div>
    </div>

    <div class="container">
        <div class="phone-interface">
            <div class="phone-header">
                <h1 class="phone-title">AI Phone Call</h1>
                <p class="phone-subtitle">Have a natural conversation with AI, just like a real phone call!</p>
            </div>

            <div class="call-status status-idle" id="callStatus">
                <div class="status-text" id="statusText">Ready to dial</div>
                <div class="status-details" id="statusDetails">Click the dial button to start your call</div>
                <div class="call-timer" id="callTimer">00:00</div>
                <!-- üåê WEBSOCKET STATUS -->
                <div class="websocket-status" id="websocketStatus" style="margin-top: 5px; font-size: 0.8rem;">
                    <span id="wsIndicator" style="color: #666;">üî¥ Not connected</span>
                </div>
                
                <!-- üß™ DEBUG CONTROLS -->
                <div class="debug-controls" style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 5px; font-size: 0.8rem;" id="debugControls">
                    <div style="font-weight: bold; margin-bottom: 5px; color: #666;">üß™ Debug Controls</div>
                    <button onclick="testAudioChunks()" class="btn btn-sm btn-secondary" style="margin-right: 5px; font-size: 0.7rem;">Test Audio Chunks</button>
                    <button onclick="console.clear()" class="btn btn-sm btn-light" style="margin-right: 5px; font-size: 0.7rem;">Clear Console</button>
                    <button onclick="showDebugInfo()" class="btn btn-sm btn-info" style="font-size: 0.7rem;">Show URLs</button>
                </div>
            </div>

            <!-- Process Status Indicator -->
            <div class="process-status" id="processStatus">
                <div class="process-title">Processing Status</div>
                <div class="process-stages">
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-listening">üé§</div>
                        <div class="stage-label">Listening</div>
                        <div class="stage-connector"></div>
                    </div>
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-stt">üó£Ô∏è</div>
                        <div class="stage-label">Speech Recognition</div>
                        <div class="stage-connector"></div>
                    </div>
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-transfer">üì§</div>
                        <div class="stage-label">Transfer</div>
                        <div class="stage-connector"></div>
                    </div>
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-llm">üß†</div>
                        <div class="stage-label">AI Thinking</div>
                        <div class="stage-connector"></div>
                    </div>
                    <div class="process-stage">
                        <div class="stage-icon waiting" id="stage-tts">üîä</div>
                        <div class="stage-label">Text to Speech</div>
                    </div>
                </div>
                <div class="process-details" id="processDetails">Ready to process audio</div>
                
                <!-- Agent Response Indicator -->
                <div class="agent-response-indicator" id="agentResponseIndicator">
                    <div class="response-dots">
                        <div class="response-dot"></div>
                        <div class="response-dot"></div>
                        <div class="response-dot"></div>
                    </div>
                    <span>Agent is responding...</span>
                </div>
            </div>

            <!-- Audio Visualizer -->
            <div class="audio-visualizer" id="audioVisualizer">
                <div class="visualizer-title">üé§ Audio Input</div>
                <div class="visualizer-container">
                    <div class="audio-bars" id="audioBars">
                        <!-- Audio bars will be generated by JavaScript -->
                    </div>
                    <div class="volume-indicator" id="volumeIndicator">0%</div>
                </div>
                <div class="microphone-status">
                    <div class="mic-icon" id="micIcon">üé§</div>
                    <span id="micStatus">Microphone Ready</span>
                </div>
            </div>

            <div class="conversation-display" id="conversationDisplay" style="display: none;">
                <div id="conversationMessages"></div>
            </div>

            <div class="loading-indicator" id="loadingIndicator">
                <div class="loading-dots">
                    <div></div>
                    <div></div>
                    <div></div>
                    <div></div>
                </div>
                <p>AI is thinking...</p>
            </div>

            <div class="phone-controls">
                <button class="control-button dial-button" id="dialButton" title="Start Call">
                    üìû
                </button>
                <button class="control-button interrupt-button" id="interruptButton" title="Interrupt AI" disabled>
                    ‚è∏Ô∏è
                </button>
                <button class="control-button hangup-button" id="hangupButton" title="End Call" disabled>
                    üìµ
                </button>
                <!-- üö® EMERGENCY: Noise Gate Toggle -->
                <button class="control-button noise-gate-button" id="noiseGateButton" title="Toggle Noise Gate (Currently: BYPASSED)" 
                        style="background: #dc3545; color: white;">
                    üîá
                </button>
            </div>
        </div>

        <div class="settings-panel">
            <h3 class="settings-title">Call Settings</h3>
            
            <div class="setting-group">
                <label class="setting-label">Language</label>
                <select class="setting-input" id="languageSelect">
                    <option value="en">English</option>
                    <option value="zh">‰∏≠Êñá (Chinese)</option>
                </select>
            </div>

            <div class="setting-group">
                <label class="setting-label">AI Model</label>
                <select class="setting-input" id="modelSelect">
                    <option value="gemma2:2b" selected>Gemma2 2B (Fast, Recommended)</option>
                    <option value="llama3.2:1b">Llama 3.2 1B (Fast)</option>
                    <option value="gemma2:2b">Gemma 2 2B (Balanced)</option>
                    <option value="llama3.1:8b">Llama 3.1 8B (High Quality)</option>
                    <option value="gemma3:latest">Gemma 3 (Advanced)</option>
                    <option value="llava:latest">LLaVA (Vision Capable)</option>
                </select>
            </div>

            <div class="setting-group">
                <label class="setting-label">Voice Speed</label>
                <select class="setting-input" id="speedSelect">
                    <option value="0.8">Slow</option>
                    <option value="1.0" selected>Normal</option>
                    <option value="1.2">Fast</option>
                </select>
            </div>

            <div class="setting-group">
                <label class="setting-label">
                    Kid-Friendly Mode
                    <label class="toggle-switch">
                        <input type="checkbox" id="kidFriendlyToggle">
                        <span class="slider"></span>
                    </label>
                </label>
            </div>

            <div class="setting-group">
                <label class="setting-label">
                    Background Music
                    <label class="toggle-switch">
                        <input type="checkbox" id="backgroundMusicToggle" checked>
                        <span class="slider"></span>
                    </label>
                </label>
            </div>

            <div class="call-history">
                <h4 class="settings-title">Recent Calls</h4>
                <div id="callHistoryList">
                    <div class="history-item">
                        <div class="history-time">Today, 2:30 PM</div>
                        <div class="history-duration">Duration: 03:45</div>
                    </div>
                    <div class="history-item">
                        <div class="history-time">Yesterday, 10:15 AM</div>
                        <div class="history-duration">Duration: 01:22</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class PhoneCallInterface {
            constructor() {
                this.callState = 'idle'; // idle, dialing, connected, ended
                this.callTimer = null;
                this.heartbeatInterval = null;  // Add heartbeat mechanism
                this.connectionMonitor = null; // Add connection monitoring
                this.reconnectionAttempts = 0; // Track reconnection attempts
                this.maxReconnectionAttempts = 5; // Maximum reconnection attempts
                this.callStartTime = null;
                this.currentSessionId = null;
                this.websocket = null;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.currentAudio = null; // Track current AI audio for interrupts
                this.backgroundAudio = null; // Track background music
                this.wasRecentlySpeaking = false; // Track recent user speaking for smart interruption
                this.lastEmergencyTime = 0; // Track emergency interrupt timing to prevent spam
                this.activeAudioElements = new Set(); // Track all active audio elements
                this.lastAudioStartTime = 0; // Track when last audio started
                this.audioOverlapDetected = false; // Track if overlap is detected
                
                // üéØ ENHANCED AUDIO BUFFERING for continuous speech
                this.audioBuffer = []; // Buffer for accumulating audio chunks
                this.lastSpeechTime = 0; // Track when user last spoke
                this.speechThreshold = 2000; // 2KB minimum for speech (was 1000)
                this.silenceTimeout = 3000; // 3 seconds of silence before sending (was immediate)
                // üîä NOISE GATE & VOICE ACTIVITY DETECTION
                this.noiseGate = {
                    enabled: false, // üö® EMERGENCY: Disable by default for immediate usability
                    volumeThreshold: 5, // Very low threshold - almost always allow
                    silenceThreshold: 500, // ms of silence before stopping recording
                    speechThreshold: 50, // Very fast speech detection
                    lastSpeechTime: 0,
                    lastSilenceTime: 0,
                    isRecordingValid: true, // üö® EMERGENCY: Always allow recording initially
                    backgroundNoiseLevel: 0,
                    calibrationSamples: [],
                    calibrated: true, // üö® EMERGENCY: Skip calibration
                    // üéØ EMERGENCY: Manual override controls
                    manualOverride: true, // üö® EMERGENCY: Always override
                    adaptiveMode: false, // üö® EMERGENCY: Disable adaptive mode
                    bypassMode: true // üö® EMERGENCY: Complete bypass
                };

                // üîç TIMING ENHANCEMENT: Add queue and network delays
                this.timingEnhancements = {
                    queueTime: 0,
                    networkLatency: 0,
                    serverQueueDepth: 0,
                    connectionQuality: 'good'
                };

                // üö® WEBSOCKET RECONNECTION: Auto-reconnect for stable audio
                this.websocketConfig = {
                    maxReconnectAttempts: 5,
                    reconnectAttempts: 0,
                    reconnectDelay: 1000,
                    isReconnecting: false,
                    lastPingTime: 0,
                    pingInterval: null
                };

                this.maxBufferTime = 8000; // 8 seconds max buffer before forced send
                this.bufferStartTime = 0; // When current buffer started
                
                // üîç PERFORMANCE PROFILER - Track all timing data
                this.performanceProfiler = {
                    sessionStart: 0,
                    stages: {},
                    currentStage: null,
                    totalTimes: {
                        audioCapture: [],
                        audioTransfer: [],
                        sttProcessing: [],
                        llmProcessing: [],
                        ttsGeneration: [],
                        audioPlayback: [],
                        endToEnd: []
                    }
                };
                
                this.initializeElements();
                this.setupEventListeners();
                this.setupAudioPermissions();
            }

            initializeElements() {
                this.dialButton = document.getElementById('dialButton');
                this.hangupButton = document.getElementById('hangupButton');
                this.interruptButton = document.getElementById('interruptButton');
                this.noiseGateButton = document.getElementById('noiseGateButton'); // üö® EMERGENCY CONTROL
                this.statusText = document.getElementById('statusText');
                this.statusDetails = document.getElementById('statusDetails');
                this.callTimerDisplay = document.getElementById('callTimer');
                this.conversationDisplay = document.getElementById('conversationDisplay');
                this.conversationMessages = document.getElementById('conversationMessages');
                this.loadingIndicator = document.getElementById('loadingIndicator');
                this.callStatus = document.getElementById('callStatus');
                
                // Process status elements
                this.processStatus = document.getElementById('processStatus');
                this.processDetails = document.getElementById('processDetails');
                
                // EMERGENCY INTERRUPT: Initialize keyword detection
                this.emergencyKeywords = [
                    'okay-dokay',           // üéØ USER'S MAGIC WORD
                    'okaydokay',           // Single word version
                    'okay dokay',          // Spaced version
                    'okaydokay okaydokay', // Original double version
                    'okayokday okayokday', // Typo-tolerant variant
                    'stop stop',           // Backup emergency
                    'emergency interrupt'   // System emergency
                ];
                this.lastEmergencyTime = 0; // Prevent spam
                this.agentResponseIndicator = document.getElementById('agentResponseIndicator');
                
                // Audio visualizer elements
                this.audioVisualizer = document.getElementById('audioVisualizer');
                this.audioBars = document.getElementById('audioBars');
                this.volumeIndicator = document.getElementById('volumeIndicator');
                this.micIcon = document.getElementById('micIcon');
                this.micStatus = document.getElementById('micStatus');
                
                // Stage elements
                this.stageElements = {
                    listening: document.getElementById('stage-listening'),
                    stt: document.getElementById('stage-stt'),
                    transfer: document.getElementById('stage-transfer'),
                    llm: document.getElementById('stage-llm'),
                    tts: document.getElementById('stage-tts')
                };
                
                // Audio analysis
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                this.animationFrame = null;
                
                // Initialize audio bars
                this.initializeAudioBars();
                
                // Settings
                this.languageSelect = document.getElementById('languageSelect');
                this.modelSelect = document.getElementById('modelSelect');
                this.speedSelect = document.getElementById('speedSelect');
                this.kidFriendlyToggle = document.getElementById('kidFriendlyToggle');
                this.backgroundMusicToggle = document.getElementById('backgroundMusicToggle');
            }

            // Process Status Management
            showProcessStatus() {
                this.processStatus.classList.add('active');
                this.resetProcessStages();
            }

            hideProcessStatus() {
                this.processStatus.classList.remove('active');
                this.agentResponseIndicator.classList.remove('active');
            }

            resetProcessStages() {
                Object.values(this.stageElements).forEach(element => {
                    element.className = 'stage-icon waiting';
                });
                this.updateProcessDetails('Ready to process audio');
                this.agentResponseIndicator.classList.remove('active');
            }

            setStageStatus(stageName, status, details = '') {
                const element = this.stageElements[stageName];
                if (!element) return;

                // Reset all stage classes
                element.className = 'stage-icon';
                
                switch (status) {
                    case 'active':
                        element.classList.add('active');
                        this.updateProcessDetails(details || `${this.getStageName(stageName)} in progress...`);
                        break;
                    case 'completed':
                        element.classList.add('completed');
                        break;
                    case 'error':
                        element.classList.add('error');
                        this.updateProcessDetails(details || `Error in ${this.getStageName(stageName)}`);
                        break;
                    default:
                        element.classList.add('waiting');
                }
            }

            getStageName(stageKey) {
                const stageNames = {
                    listening: 'Audio Capture',
                    stt: 'Speech Recognition',
                    transfer: 'Data Transfer',
                    llm: 'AI Processing',
                    tts: 'Speech Synthesis'
                };
                return stageNames[stageKey] || stageKey;
            }

            updateProcessDetails(message) {
                if (this.processDetails) {
                    this.processDetails.textContent = message;
                }
            }

            showAgentResponse() {
                this.agentResponseIndicator.classList.add('active');
            }

            hideAgentResponse() {
                this.agentResponseIndicator.classList.remove('active');
            }

            // Process flow management
            startProcessFlow() {
                this.showProcessStatus();
                this.setStageStatus('listening', 'active', 'Capturing audio...');
            }

            completeListening() {
                this.setStageStatus('listening', 'completed');
                this.setStageStatus('stt', 'active', 'Converting speech to text...');
            }

            completeSpeechRecognition(transcription = '') {
                // EMERGENCY INTERRUPT: Check for emergency keywords first
                if (transcription && this.checkEmergencyInterrupt(transcription)) {
                    console.log('üö® Emergency interrupt detected in transcription, stopping processing');
                    return; // Stop all further processing
                }
                
                this.setStageStatus('stt', 'completed');
                this.setStageStatus('transfer', 'active', 'Sending data to server...');
                if (transcription) {
                    this.updateProcessDetails(`Recognized: "${transcription}"`);
                }
            }

            completeTransfer() {
                this.setStageStatus('transfer', 'completed');
                this.setStageStatus('llm', 'active', 'AI is thinking...');
                this.showAgentResponse();
            }

            completeLLMProcessing() {
                this.setStageStatus('llm', 'completed');
                this.setStageStatus('tts', 'active', 'Generating speech...');
                this.hideAgentResponse();
            }

            completeTTSProcessing() {
                this.setStageStatus('tts', 'completed');
                this.updateProcessDetails('Response ready - playing audio');
                
                // Reset after a short delay
                setTimeout(() => {
                    this.resetProcessStages();
                }, 2000);
            }

            handleProcessError(stage, error) {
                this.setStageStatus(stage, 'error', `Error: ${error}`);
                this.hideAgentResponse();
                
                // Reset after error display
                setTimeout(() => {
                    this.resetProcessStages();
                }, 3000);
            }

            // Audio Visualizer Methods
            initializeAudioBars() {
                // Create 20 audio bars
                const numBars = 20;
                this.audioBars.innerHTML = '';
                
                for (let i = 0; i < numBars; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    bar.style.height = '2px';
                    this.audioBars.appendChild(bar);
                }
            }

            showAudioVisualizer() {
                this.audioVisualizer.classList.add('active');
            }

            hideAudioVisualizer() {
                this.audioVisualizer.classList.remove('active');
                this.stopAudioVisualization();
            }

            async setupAudioVisualization(stream) {
                try {
                    // Create audio context and analyser
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    
                    // Configure analyser
                    this.analyser.fftSize = 64; // Lower value for simpler visualization
                    this.analyser.smoothingTimeConstant = 0.8;
                    
                    // Connect microphone stream to analyser
                    const source = this.audioContext.createMediaStreamSource(stream);
                    source.connect(this.analyser);
                    
                    // Create data array for frequency data
                    const bufferLength = this.analyser.frequencyBinCount;
                    this.dataArray = new Uint8Array(bufferLength);
                    
                    // Start visualization
                    this.startAudioVisualization();
                    
                    this.updateMicrophoneStatus('active', 'Recording audio...');
                    
                } catch (error) {
                    console.error('Failed to setup audio visualization:', error);
                    this.updateMicrophoneStatus('error', 'Visualization unavailable');
                }
            }

            startAudioVisualization() {
                if (!this.analyser || !this.dataArray) return;
                
                const visualize = () => {
                    this.animationFrame = requestAnimationFrame(visualize);
                    
                    // Get frequency data
                    this.analyser.getByteFrequencyData(this.dataArray);
                    
                    // Calculate average volume
                    let sum = 0;
                    for (let i = 0; i < this.dataArray.length; i++) {
                        sum += this.dataArray[i];
                    }
                    const average = sum / this.dataArray.length;
                    const volumePercent = Math.round((average / 255) * 100);
                    
                    // üîä VOICE ACTIVITY DETECTION: Process volume for noise gating
                    this.processVoiceActivity(volumePercent);
                    
                    // Update volume indicator with noise gate status
                    const gateStatus = this.noiseGate.bypassMode ? 'üö®' : (this.noiseGate.isRecordingValid ? 'üîä' : 'üîá');
                    this.volumeIndicator.textContent = `${gateStatus} ${volumePercent}%`;
                    
                    // Color code volume indicator based on noise gate
                    if (this.noiseGate.bypassMode) {
                        this.volumeIndicator.style.color = '#dc3545'; // Red for bypass mode
                    } else if (this.noiseGate.isRecordingValid) {
                        this.volumeIndicator.style.color = '#28a745'; // Green for valid speech
                    } else if (volumePercent > this.noiseGate.volumeThreshold) {
                        this.volumeIndicator.style.color = '#ffc107'; // Yellow for volume but below speech threshold
                    } else {
                        this.volumeIndicator.style.color = '#6c757d'; // Gray for silence/noise
                    }
                    
                    // Update audio bars
                    const bars = this.audioBars.children;
                    const dataStep = this.dataArray.length / bars.length;
                    
                    for (let i = 0; i < bars.length; i++) {
                        const dataIndex = Math.floor(i * dataStep);
                        const value = this.dataArray[dataIndex];
                        const height = Math.max(2, (value / 255) * 60); // Min 2px, max 60px
                        
                        bars[i].style.height = `${height}px`;
                        
                        // Add active class for bars with significant activity
                        if (value > 30) {
                            bars[i].classList.add('active');
                        } else {
                            bars[i].classList.remove('active');
                        }
                    }
                    
                    // Update microphone status based on activity
                    if (average > 10) {
                        this.updateMicrophoneStatus('active', 'Detecting audio...');
                    } else {
                        this.updateMicrophoneStatus('idle', 'Listening...');
                    }
                };
                
                visualize();
            }

            stopAudioVisualization() {
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                
                // Reset bars
                const bars = this.audioBars.children;
                for (let bar of bars) {
                    bar.style.height = '2px';
                    bar.classList.remove('active');
                }
                
                // Reset volume indicator
                this.volumeIndicator.textContent = '0%';
                
                this.updateMicrophoneStatus('inactive', 'Microphone inactive');
            }

            // üîä VOICE ACTIVITY DETECTION: Intelligent noise gating and speech detection
            processVoiceActivity(volumePercent) {
                const now = Date.now();
                
                // üìä CALIBRATION: Learn background noise level during first few seconds
                if (!this.noiseGate.calibrated) {
                    this.noiseGate.calibrationSamples.push(volumePercent);
                    
                    if (this.noiseGate.calibrationSamples.length >= 50) { // 50 samples ‚âà 2-3 seconds
                        // Calculate background noise level (median of samples)
                        const sorted = [...this.noiseGate.calibrationSamples].sort((a, b) => a - b);
                        this.noiseGate.backgroundNoiseLevel = sorted[Math.floor(sorted.length / 2)];
                        
                        // Set adaptive threshold: background + 8-15 units above noise floor
                        this.noiseGate.volumeThreshold = Math.max(15, this.noiseGate.backgroundNoiseLevel + 12);
                        
                        this.noiseGate.calibrated = true;
                        console.log(`üîä Noise calibration complete: Background=${this.noiseGate.backgroundNoiseLevel}%, Threshold=${this.noiseGate.volumeThreshold}%`);
                        
                        // Show calibration results to user
                        this.addMessage('system', 
                            `üîä <span style="color: green;">Voice detection calibrated</span> - Background: ${this.noiseGate.backgroundNoiseLevel}%, Speech threshold: ${this.noiseGate.volumeThreshold}%`
                        );
                    }
                    return; // Still calibrating
                }
                
                // üéØ VOICE ACTIVITY DETECTION: Determine if current audio is speech
                const isSpeech = volumePercent > this.noiseGate.volumeThreshold;
                
                if (isSpeech) {
                    this.noiseGate.lastSpeechTime = now;
                    
                    // Start recording if we have sustained speech
                    if (!this.noiseGate.isRecordingValid) {
                        const speechDuration = now - (this.noiseGate.lastSilenceTime || now);
                        if (speechDuration >= this.noiseGate.speechThreshold) {
                            this.noiseGate.isRecordingValid = true;
                            console.log(`üîä Speech detected - Starting valid recording (${volumePercent}% > ${this.noiseGate.volumeThreshold}%)`);
                            this.updateMicrophoneStatus('active', `üîä Recording speech (${volumePercent}%)`);
                        }
                    }
                } else {
                    this.noiseGate.lastSilenceTime = now;
                    
                    // Stop recording if we have sustained silence
                    if (this.noiseGate.isRecordingValid) {
                        const silenceDuration = now - this.noiseGate.lastSpeechTime;
                        if (silenceDuration >= this.noiseGate.silenceThreshold) {
                            this.noiseGate.isRecordingValid = false;
                            console.log(`üîá Silence detected - Stopping recording (${silenceDuration}ms silence)`);
                            this.updateMicrophoneStatus('idle', `üîá Listening... (${volumePercent}%)`);
                        }
                    }
                }
            }

            updateMicrophoneStatus(status, message) {
                this.micStatus.textContent = message;
                
                // Update microphone icon
                switch (status) {
                    case 'active':
                        this.micIcon.style.background = '#28a745';
                        this.micIcon.textContent = 'üé§';
                        this.micIcon.classList.remove('muted');
                        break;
                    case 'idle':
                        this.micIcon.style.background = '#ffc107';
                        this.micIcon.textContent = 'üé§';
                        this.micIcon.classList.remove('muted');
                        break;
                    case 'processing':
                        this.micIcon.style.background = '#007bff';
                        this.micIcon.textContent = '‚ö°';
                        this.micIcon.classList.remove('muted');
                        break;
                    case 'inactive':
                    case 'error':
                        this.micIcon.style.background = '#dc3545';
                        this.micIcon.textContent = 'üö´';
                        this.micIcon.classList.add('muted');
                        break;
                }
            }

            setupEventListeners() {
                this.dialButton.addEventListener('click', () => this.startCall());
                this.hangupButton.addEventListener('click', () => this.endCall());
                this.interruptButton.addEventListener('click', () => this.interruptAI());
                
                // ÔøΩ EMERGENCY: Noise Gate Toggle Button
                this.noiseGateButton.addEventListener('click', () => this.toggleNoiseGate());
                
                // ÔøΩüîç PERFORMANCE: Add keyboard shortcut for performance report (Ctrl+P)
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'p') {
                        e.preventDefault();
                        this.showPerformanceReport();
                    }
                });
                
                // Settings change handlers
                this.languageSelect.addEventListener('change', () => this.updateSettings());
                this.modelSelect.addEventListener('change', () => this.updateSettings());
                this.speedSelect.addEventListener('change', () => this.updateSettings());
                this.kidFriendlyToggle.addEventListener('change', () => this.updateSettings());
                this.backgroundMusicToggle.addEventListener('change', () => this.updateSettings());
            }

            // üîç PERFORMANCE: Show detailed performance report
            showPerformanceReport() {
                const report = this.getPerformanceReport();
                
                let html = `<div style="font-family: monospace; background: #e8f4fd; padding: 15px; border-radius: 8px; margin: 10px 0;">`;
                html += `<h3>üìä COMPREHENSIVE PERFORMANCE REPORT</h3>`;
                
                // Current session
                html += `<h4>Current Session:</h4>`;
                for (const [stage, data] of Object.entries(this.performanceProfiler.stages)) {
                    if (data.duration) {
                        const emoji = this.getStageEmoji(stage);
                        const color = this.getPerformanceColor(data.duration);
                        html += `${emoji} <span style="color: ${color};">${stage}: ${data.duration.toFixed(0)}ms</span><br/>`;
                    }
                }
                
                // Averages
                html += `<h4>Session Averages:</h4>`;
                for (const [stage, stats] of Object.entries(report.averages)) {
                    const emoji = this.getStageEmoji(stage);
                    html += `${emoji} ${stage}: Avg ${stats.average}ms (${stats.count} samples)<br/>`;
                    html += `&nbsp;&nbsp;&nbsp;Range: ${stats.min}ms - ${stats.max}ms<br/>`;
                }
                
                html += `<br/><small>üí° Press Ctrl+P to show this report anytime</small>`;
                html += `</div>`;
                
                this.conversationMessages.innerHTML += `<div class="message system-message">${html}</div>`;
                this.conversationMessages.scrollTop = this.conversationMessages.scrollHeight;
            }

            async setupAudioPermissions() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());
                    console.log('Audio permissions granted');
                } catch (error) {
                    console.error('Audio permissions denied:', error);
                    this.updateStatus('error', 'Microphone access required for phone calls');
                }
            }

            // EMERGENCY INTERRUPT: Check for emergency keywords in transcribed text
            checkEmergencyInterrupt(text) {
                if (!text) return false;
                
                const textLower = text.toLowerCase().trim();
                console.log('üéØ Checking for MAGIC WORD "okay-dokay" in:', textLower);
                
                for (const keyword of this.emergencyKeywords) {
                    if (textLower.includes(keyword)) {
                        const now = Date.now();
                        // Reduced cooldown for more responsive magic word detection
                        if (now - this.lastEmergencyTime > 1000) { // 1 second cooldown (was 3)
                            this.lastEmergencyTime = now;
                            console.log('üö® MAGIC WORD DETECTED:', keyword);
                            this.handleEmergencyInterrupt(keyword);
                            return true;
                        } else {
                            console.log('üö® Magic word detected but in cooldown period');
                        }
                    }
                }
                return false;
            }

            // EMERGENCY INTERRUPT: Handle emergency interrupt actions
            handleEmergencyInterrupt(keyword) {
                console.log('üö® MAGIC WORD ACTIVATED - EXECUTING IMMEDIATE STOP...');
                
                // 1. IMMEDIATE AUDIO STOP - HIGHEST PRIORITY
                this.stopCurrentAudio();
                this.stopBackgroundMusic();
                
                // 2. Stop loading/processing indicators
                this.showLoading(false);
                this.hideProcessStatus();
                
                // 3. Send emergency interrupt signal to server
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify({
                        type: 'emergency_interrupt',
                        session_id: this.currentSessionId,
                        keyword: keyword,
                        timestamp: Date.now()
                    }));
                }
                
                // 4. Enhanced visual feedback for magic word
                if (keyword.includes('okay-dokay') || keyword.includes('okaydokay')) {
                    this.addMessage('system', `üéØ MAGIC WORD "${keyword}" activated - All audio stopped immediately!`);
                    this.updateStatus('ready', 'üéØ Magic word detected - Ready for new input');
                } else {
                    this.addMessage('system', `üö® Emergency interrupt "${keyword}" activated`);
                    this.updateStatus('ready', 'Emergency interrupt - ready for new input');
                }
                this.updateMicrophoneStatus('idle', 'Ready for input...');
            }

            // üö® OVERLAP DETECTION: Periodic check for overlapping audio
            startOverlapDetection() {
                // Check every 500ms for overlapping audio
                this.overlapCheckInterval = setInterval(() => {
                    const activeCount = this.activeAudioElements.size;
                    const hasCurrentAudio = this.currentAudio && !this.currentAudio.paused;
                    
                    // If we have more than 1 active audio or current audio + other active elements
                    if (activeCount > 1 || (hasCurrentAudio && activeCount > 0 && this.currentAudio && !this.activeAudioElements.has(this.currentAudio))) {
                        console.log(`üö® OVERLAP DETECTED: ${activeCount} active elements, current audio: ${hasCurrentAudio}`);
                        this.addMessage('system', `üö® Audio overlap detected (${activeCount} streams) - cleaning up`);
                        this.stopCurrentAudio();
                    }
                }, 500);
            }

            // üö® OVERLAP DETECTION: Stop periodic overlap checking
            stopOverlapDetection() {
                if (this.overlapCheckInterval) {
                    clearInterval(this.overlapCheckInterval);
                    this.overlapCheckInterval = null;
                }
            }

            // üîç PERFORMANCE PROFILER: Start timing a stage
            startTiming(stageName) {
                const now = performance.now();
                this.performanceProfiler.stages[stageName] = {
                    start: now,
                    end: null,
                    duration: null
                };
                this.performanceProfiler.currentStage = stageName;
                console.log(`‚è±Ô∏è TIMING START: ${stageName} at ${now.toFixed(2)}ms`);
            }

            // üîç PERFORMANCE PROFILER: End timing a stage
            endTiming(stageName) {
                const now = performance.now();
                const stage = this.performanceProfiler.stages[stageName];
                if (stage && stage.start) {
                    stage.end = now;
                    stage.duration = now - stage.start;
                    console.log(`‚è±Ô∏è TIMING END: ${stageName} took ${stage.duration.toFixed(2)}ms`);
                    
                    // Add to historical data
                    if (this.performanceProfiler.totalTimes[stageName]) {
                        this.performanceProfiler.totalTimes[stageName].push(stage.duration);
                    }
                    
                    // Show timing in UI
                    this.displayTimingInfo(stageName, stage.duration);
                } else {
                    console.warn(`‚è±Ô∏è No start time found for stage: ${stageName}`);
                }
            }

            // üîç PERFORMANCE PROFILER: Display timing info in conversation
            displayTimingInfo(stageName, duration) {
                const color = duration > 3000 ? 'red' : duration > 1000 ? 'orange' : 'green';
                const emoji = duration > 3000 ? 'üêå' : duration > 1000 ? '‚ö°' : 'üöÄ';
                this.addMessage('system', 
                    `${emoji} <span style="color: ${color}; font-weight: bold;">${stageName}: ${duration.toFixed(0)}ms</span>`
                );
            }

            // üîç PERFORMANCE PROFILER: Set server-side timing to override client estimates
            setServerTiming(stageName, serverDurationMs) {
                if (this.performanceProfiler.stages[stageName]) {
                    const originalDuration = this.performanceProfiler.stages[stageName].duration;
                    
                    // Override with actual server timing
                    this.performanceProfiler.stages[stageName].duration = serverDurationMs;
                    this.performanceProfiler.stages[stageName].serverTiming = true;
                    this.performanceProfiler.stages[stageName].originalClientDuration = originalDuration;
                    
                    console.log(`‚ö° Server timing override: ${stageName} - Client: ${originalDuration}ms ‚Üí Server: ${serverDurationMs}ms`);
                    
                    // Update total times with server data
                    if (this.performanceProfiler.totalTimes[stageName]) {
                        this.performanceProfiler.totalTimes[stageName].push(serverDurationMs);
                    }
                }
            }

            // üîç PERFORMANCE PROFILER: Display real-time stats during conversation
            displayRealTimeStats() {
                const stages = this.performanceProfiler.stages;
                let quickStats = [];
                
                // üåê NETWORK & QUEUE DELAYS - Show hidden delays
                if (this.timingEnhancements.networkLatency > 0) {
                    quickStats.push(`üåê Network: ${this.timingEnhancements.networkLatency}ms`);
                }
                
                if (this.timingEnhancements.queueTime > 0) {
                    quickStats.push(`üìã Queue: ${this.timingEnhancements.queueTime}ms`);
                }
                
                // üîä NOISE GATE STATUS - Show voice detection
                if (this.noiseGate.calibrated) {
                    const gateStatus = this.noiseGate.isRecordingValid ? 'üîä' : 'üîá';
                    quickStats.push(`${gateStatus} Gate: ${this.noiseGate.volumeThreshold}%`);
                }
                
                if (stages.llmProcessing?.duration) {
                    const isServerTiming = stages.llmProcessing.serverTiming;
                    const emoji = isServerTiming ? "üåê" : "üì±";
                    quickStats.push(`${emoji} LLM: ${stages.llmProcessing.duration.toFixed(0)}ms`);
                }
                
                if (stages.ttsGeneration?.duration) {
                    const isServerTiming = stages.ttsGeneration.serverTiming;
                    const emoji = isServerTiming ? "üåê" : "üì±";
                    quickStats.push(`${emoji} TTS: ${stages.ttsGeneration.duration.toFixed(0)}ms`);
                }
                
                if (stages.endToEnd?.duration) {
                    quickStats.push(`‚ö° Total: ${stages.endToEnd.duration.toFixed(0)}ms`);
                }
                
                if (quickStats.length > 0) {
                    const statsMessage = `üìä ${quickStats.join(' | ')}`;
                    this.addMessage('system', `<span style="color: #666; font-size: 0.9em;">${statsMessage}</span>`);
                    console.log(`üîç Comprehensive stats: ${quickStats.join(' | ')}`);
                }
            }

            // üîç PERFORMANCE PROFILER: Get comprehensive timing report
            getPerformanceReport() {
                const report = {
                    currentSession: this.performanceProfiler.stages,
                    averages: {}
                };
                
                // Calculate averages for each stage
                for (const [stage, times] of Object.entries(this.performanceProfiler.totalTimes)) {
                    if (times.length > 0) {
                        const avg = times.reduce((a, b) => a + b, 0) / times.length;
                        const min = Math.min(...times);
                        const max = Math.max(...times);
                        report.averages[stage] = {
                            average: avg.toFixed(2),
                            min: min.toFixed(2),
                            max: max.toFixed(2),
                            count: times.length
                        };
                    }
                }
                
                console.table(report.averages);
                return report;
            }

            // üîç PERFORMANCE PROFILER: Display comprehensive performance summary
            displayPerformanceSummary() {
                const stages = this.performanceProfiler.stages;
                if (!stages.endToEnd || !stages.endToEnd.duration) return;
                
                const totalTime = stages.endToEnd.duration;
                
                // Create detailed breakdown
                const breakdown = [];
                const stageOrder = ['audioCapture', 'audioTransfer', 'sttProcessing', 'llmProcessing', 'ttsGeneration', 'audioPlayback'];
                
                let html = `<div style="font-family: monospace; background: #f5f5f5; padding: 10px; border-radius: 5px; margin: 5px 0;">`;
                html += `<strong>üîç PERFORMANCE BREAKDOWN (Total: ${totalTime.toFixed(0)}ms)</strong><br/>`;
                
                for (const stage of stageOrder) {
                    if (stages[stage] && stages[stage].duration) {
                        const duration = stages[stage].duration;
                        const percentage = ((duration / totalTime) * 100).toFixed(1);
                        const emoji = this.getStageEmoji(stage);
                        const color = this.getPerformanceColor(duration);
                        const isServerTiming = stages[stage].serverTiming;
                        const timingSource = isServerTiming ? "üåê" : "üì±";
                        
                        let timingInfo = `${timingSource} ${stage}: ${duration.toFixed(0)}ms (${percentage}%)`;
                        
                        // Show client vs server timing comparison if available
                        if (isServerTiming && stages[stage].originalClientDuration) {
                            const clientDuration = stages[stage].originalClientDuration;
                            timingInfo += ` [Client: ${clientDuration.toFixed(0)}ms]`;
                        }
                        
                        html += `${emoji} <span style="color: ${color};">${timingInfo}</span><br/>`;
                        breakdown.push({ stage, duration, percentage });
                    }
                }
                
                // Identify bottleneck
                const slowest = breakdown.reduce((max, current) => 
                    current.duration > max.duration ? current : max, { duration: 0 });
                
                if (slowest.duration > 0) {
                    html += `<br/><strong style="color: red;">üêå BOTTLENECK: ${slowest.stage} (${slowest.percentage}%)</strong>`;
                }
                
                html += `</div>`;
                
                // Add to conversation
                this.conversationMessages.innerHTML += `<div class="message system-message">${html}</div>`;
                this.conversationMessages.scrollTop = this.conversationMessages.scrollHeight;
            }

            // üîç Helper functions for performance display
            getStageEmoji(stage) {
                const emojis = {
                    audioCapture: 'üéôÔ∏è',
                    audioTransfer: 'üì°',
                    sttProcessing: 'üëÇ',
                    llmProcessing: 'üß†',
                    ttsGeneration: 'üó£Ô∏è',
                    audioPlayback: 'üîä',
                    endToEnd: '‚è±Ô∏è'
                };
                return emojis[stage] || '‚ö°';
            }

            getPerformanceColor(duration) {
                if (duration > 3000) return '#ff4444';      // Red for >3s
                if (duration > 1000) return '#ff8800';      // Orange for >1s
                if (duration > 500) return '#ffaa00';       // Yellow for >500ms
                return '#00aa00';                           // Green for <500ms
            }

            async startCall() {
                try {
                    this.updateCallState('dialing');
                    this.currentSessionId = this.generateSessionId();
                    
                    // üö® START OVERLAP DETECTION
                    this.startOverlapDetection();
                    console.log('üö® Overlap detection started for call session');
                    
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Setup WebSocket connection
                    await this.setupWebSocket();
                    
                    // Setup audio visualization
                    await this.setupAudioVisualization(stream);
                    
                    // Start audio recording
                    this.setupAudioRecording(stream);
                    
                    this.updateCallState('connected');
                    this.startCallTimer();
                    
                    // Show process status indicator and audio visualizer
                    this.showProcessStatus();
                    this.showAudioVisualizer();
                    
                    this.conversationDisplay.style.display = 'block';
                    this.addMessage('system', 'Call connected! Start speaking...');
                    
                } catch (error) {
                    console.error('Failed to start call:', error);
                    this.updateStatus('error', 'Failed to start call: ' + error.message);
                    this.updateCallState('idle');
                    this.hideProcessStatus();
                    this.hideAudioVisualizer();
                }
            }

            async setupWebSocket() {
                return new Promise((resolve, reject) => {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/api/phone/stream`;
                    
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('üåê WebSocket connected successfully');
                        this.websocketConfig.reconnectAttempts = 0;
                        this.websocketConfig.isReconnecting = false;
                        this.reconnectionAttempts = 0; // Reset reconnection counter
                        
                        // Update WebSocket status indicator
                        this.updateWebSocketStatus('connected');
                        
                        // Start connection monitoring
                        this.startWebSocketMonitoring();
                        
                        this.addMessage('system', '‚úÖ <span style="color: green;">Connection established</span>');
                        
                        this.websocket.send(JSON.stringify({
                            type: 'session_start',
                            session_id: this.currentSessionId,
                            settings: this.getCallSettings()
                        }));
                        
                        this.addMessage('system', 'üåê <span style="color: green;">WebSocket connected</span>');
                        resolve();
                    };
                    
                    this.websocket.onmessage = (event) => {
                        console.log('üì® WebSocket message received:', event.data);
                        this.websocketConfig.lastPingTime = Date.now();
                        
                        try {
                            const data = JSON.parse(event.data);
                            console.log('üìä Parsed WebSocket message:', data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            console.error('‚ùå Failed to parse WebSocket message:', error, 'Raw data:', event.data);
                        }
                    };
                    
                    this.websocket.onerror = (error) => {
                        console.error('üö® WebSocket error:', error);
                        this.updateWebSocketStatus('error');
                        this.addMessage('system', 'üö® <span style="color: red;">WebSocket error - attempting reconnection</span>');
                        this.attemptWebSocketReconnection();
                    };
                    
                    this.websocket.onclose = (event) => {
                        console.log('üíî WebSocket disconnected:', event.code, event.reason);
                        this.updateWebSocketStatus('disconnected');
                        this.stopWebSocketMonitoring();
                        
                        // Enhanced reconnection logic for audio processing
                        if (this.callState === 'connected' && !this.websocketConfig.isReconnecting) {
                            this.addMessage('system', 'üíî <span style="color: orange;">Connection lost during call - attempting automatic reconnection</span>');
                            
                            // Use our simpler reconnection handler
                            this.handleWebSocketReconnection();
                        } else if (event.code !== 1000 && event.code !== 1001) {
                            // Unexpected disconnection
                            this.addMessage('system', `‚ö†Ô∏è <span style="color: red;">Unexpected disconnection (code: ${event.code})</span>`);
                            this.handleWebSocketReconnection();
                        }
                    };
                });
            }

            // üåê WEBSOCKET MONITORING: Keep connection alive and detect issues
            startWebSocketMonitoring() {
                this.websocketConfig.lastPingTime = Date.now();
                
                this.websocketConfig.pingInterval = setInterval(() => {
                    const now = Date.now();
                    const timeSinceLastMessage = now - this.websocketConfig.lastPingTime;
                    
                    // If no message received in 60 seconds, connection may be dead (increased from 30s)
                    if (timeSinceLastMessage > 60000) {
                        console.warn('üö® WebSocket appears inactive - attempting reconnection');
                        this.attemptWebSocketReconnection();
                        return;
                    }
                    
                    // Send ping to keep connection alive
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.websocket.send(JSON.stringify({
                            type: 'ping',
                            timestamp: now
                        }));
                    }
                }, 15000); // Check every 15 seconds
            }

            stopWebSocketMonitoring() {
                if (this.websocketConfig.pingInterval) {
                    clearInterval(this.websocketConfig.pingInterval);
                    this.websocketConfig.pingInterval = null;
                }
            }

            // üîÑ WEBSOCKET RECONNECTION: Auto-reconnect on connection loss
            async attemptWebSocketReconnection() {
                if (this.websocketConfig.isReconnecting) return;
                
                this.websocketConfig.isReconnecting = true;
                this.websocketConfig.reconnectAttempts++;
                this.updateWebSocketStatus('reconnecting');
                
                if (this.websocketConfig.reconnectAttempts > this.websocketConfig.maxReconnectAttempts) {
                    console.error('üö® Max WebSocket reconnection attempts reached');
                    this.addMessage('system', 'üö® <span style="color: red;">Connection failed - please refresh page</span>');
                    this.updateWebSocketStatus('error');
                    this.websocketConfig.isReconnecting = false;
                    return;
                }
                
                console.log(`üîÑ WebSocket reconnection attempt ${this.websocketConfig.reconnectAttempts}/${this.websocketConfig.maxReconnectAttempts}`);
                this.addMessage('system', `üîÑ Reconnecting... (${this.websocketConfig.reconnectAttempts}/${this.websocketConfig.maxReconnectAttempts})`);
                
                // Close existing connection
                if (this.websocket) {
                    this.websocket.close();
                }
                
                // Wait before reconnecting
                await new Promise(resolve => setTimeout(resolve, this.websocketConfig.reconnectDelay));
                
                try {
                    await this.setupWebSocket();
                    console.log('‚úÖ WebSocket reconnection successful');
                    this.addMessage('system', '‚úÖ <span style="color: green;">WebSocket reconnected successfully</span>');
                } catch (error) {
                    console.error('‚ùå WebSocket reconnection failed:', error);
                    this.websocketConfig.isReconnecting = false;
                    
                    // Exponential backoff
                    this.websocketConfig.reconnectDelay *= 2;
                    setTimeout(() => this.attemptWebSocketReconnection(), this.websocketConfig.reconnectDelay);
                }
            }

            // üåê WEBSOCKET STATUS: Update connection status indicator
            updateWebSocketStatus(status) {
                const indicator = document.getElementById('wsIndicator');
                if (!indicator) return;
                
                switch (status) {
                    case 'connected':
                        indicator.innerHTML = 'üü¢ Connected';
                        indicator.style.color = '#28a745';
                        break;
                    case 'connecting':
                        indicator.innerHTML = 'üü° Connecting...';
                        indicator.style.color = '#ffc107';
                        break;
                    case 'disconnected':
                        indicator.innerHTML = 'üî¥ Disconnected';
                        indicator.style.color = '#dc3545';
                        break;
                    case 'error':
                        indicator.innerHTML = 'üö® Error';
                        indicator.style.color = '#dc3545';
                        break;
                    case 'reconnecting':
                        indicator.innerHTML = 'üîÑ Reconnecting...';
                        indicator.style.color = '#007bff';
                        break;
                }
            }

            setupAudioRecording(stream) {
                console.log('Setting up audio recording...');
                this.mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                this.mediaRecorder.ondataavailable = (event) => {
                    console.log('Audio data available:', event.data.size, 'bytes');
                    if (event.data.size > 0) {
                        this.audioChunks.push(event.data);
                    } else {
                        console.warn('Received empty audio data');
                    }
                };

                this.mediaRecorder.onstop = () => {
                    console.log('MediaRecorder stopped. Audio chunks:', this.audioChunks.length);
                    if (this.audioChunks.length > 0) {
                        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                        console.log('Sending audio blob of size:', audioBlob.size, 'bytes');
                        this.sendAudioData(audioBlob);
                        this.audioChunks = [];
                    } else {
                        console.warn('No audio chunks to send');
                    }
                };

                this.mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                };

                // üéØ ENHANCED: Record in longer chunks with smart buffering
                console.log('Starting MediaRecorder with enhanced buffering...');
                this.mediaRecorder.start();
                this.recordingInterval = setInterval(() => {
                    if (this.mediaRecorder.state === 'recording') {
                        console.log('Cycling MediaRecorder - stop and restart');
                        this.mediaRecorder.stop();
                        this.mediaRecorder.start();
                    } else {
                        console.warn('MediaRecorder not in recording state:', this.mediaRecorder.state);
                    }
                }, 1500); // Shorter chunks (1.5s) for better buffering but less fragmentation
            }

            // üéØ ENHANCED AUDIO BUFFERING: Smart buffering with emergency bypass
            sendAudioData(audioBlob) {
                const now = Date.now();
                console.log('üéµ Audio chunk received:', audioBlob.size, 'bytes');
                
                // üö® EMERGENCY BYPASS: Skip noise gate if in bypass mode
                if (this.noiseGate.bypassMode) {
                    console.log('üö® BYPASS MODE: Processing all audio without noise gate');
                } else {
                    // üîä NOISE GATE: Only process audio if voice activity was detected
                    if (!this.noiseGate.calibrated) {
                        console.log('üîä Dropping audio - noise gate still calibrating');
                        return;
                    }
                    
                    if (!this.noiseGate.isRecordingValid && !this.noiseGate.manualOverride) {
                        console.log('üîá Dropping audio - no voice activity detected (background noise)');
                        return;
                    }
                }
                
                // Audio passed noise gate or is bypassed - process normally
                const hasSignificantAudio = audioBlob.size >= this.speechThreshold;
                
                if (hasSignificantAudio) {
                    // Add to buffer and update speech time
                    this.audioBuffer.push(audioBlob);
                    this.lastSpeechTime = now;
                    
                    // Start buffer timer on first chunk
                    if (this.audioBuffer.length === 1) {
                        this.bufferStartTime = now;
                        const mode = this.noiseGate.bypassMode ? 'BYPASS' : 'FILTERED';
                        console.log(`üéµ Started new audio buffer with ${mode} mode`);
                    }
                    
                    console.log(`üéµ Added to buffer (${this.audioBuffer.length} chunks, ${this.getTotalBufferSize()}KB)`);
                } else {
                    console.log('üîá Audio chunk too small, likely noise artifact');
                }
                
                // Check if we should send the buffer
                const timeSinceLastSpeech = now - this.lastSpeechTime;
                const totalBufferTime = now - this.bufferStartTime;
                const shouldSendBuffer = this.audioBuffer.length > 0 && (
                    timeSinceLastSpeech >= this.silenceTimeout ||  // 3 seconds of silence
                    totalBufferTime >= this.maxBufferTime          // 8 seconds max buffer
                );
                
                if (shouldSendBuffer) {
                    this.sendBufferedAudio();
                }
            }

            // üéØ ENHANCED: Get total size of audio buffer
            getTotalBufferSize() {
                return Math.round(this.audioBuffer.reduce((total, blob) => total + blob.size, 0) / 1024);
            }

            // üéØ ENHANCED: Send accumulated audio buffer as one chunk
            async sendBufferedAudio() {
                if (this.audioBuffer.length === 0) return;
                
                // üîç COMPREHENSIVE PERFORMANCE TIMING: Track all delays
                const transmissionStart = performance.now();
                this.startTiming('endToEnd');
                this.startTiming('audioCapture');
                this.startTiming('networkLatency'); // Track actual network round-trip
                
                console.log(`üöÄ Sending buffered audio: ${this.audioBuffer.length} chunks, ${this.getTotalBufferSize()}KB`);
                
                try {
                    // Combine all audio chunks into one blob
                    const combinedBlob = new Blob(this.audioBuffer, { type: 'audio/webm' });
                    console.log(`üéµ Combined audio blob: ${Math.round(combinedBlob.size / 1024)}KB`);
                    
                    this.endTiming('audioCapture');
                    this.startTiming('audioTransfer');
                    
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.startProcessFlow();
                        
                        const reader = new FileReader();
                        reader.onload = () => {
                            this.completeListening();
                            
                            const audioData = reader.result.split(',')[1]; // Remove data URL prefix
                            
                            // üîç TIMING: Measure WebSocket send time
                            const websocketSendStart = performance.now();
                            const message = {
                                type: 'audio_data',
                                session_id: this.currentSessionId,
                                audio_data: audioData,
                                timestamp: Date.now(),
                                client_sent_at: Date.now(), // For network latency calculation
                                is_silence: false,  // Buffered audio is never silence
                                buffer_info: {
                                    chunks: this.audioBuffer.length,
                                    total_size_kb: this.getTotalBufferSize(),
                                    duration_ms: Date.now() - this.bufferStartTime
                                },
                                // üîç COMPREHENSIVE TIMING DATA
                                client_timing: {
                                    audio_capture_ms: this.performanceProfiler.stages.audioCapture?.duration || 0,
                                    transfer_start: performance.now(),
                                    noise_gate_calibrated: this.noiseGate.calibrated,
                                    speech_threshold: this.noiseGate.volumeThreshold,
                                    background_noise: this.noiseGate.backgroundNoiseLevel
                                }
                            };
                            
                            // Store send time for latency calculation
                            this.timingEnhancements.lastSendTime = Date.now();
                            
                            console.log('üöÄ Sending combined audio:', {
                                type: message.type,
                                chunks: message.buffer_info.chunks,
                                size_kb: message.buffer_info.total_size_kb,
                                duration_ms: message.buffer_info.duration_ms,
                                capture_time: message.client_timing.audio_capture_ms
                            });
                            
                            this.websocket.send(JSON.stringify(message));
                            this.endTiming('audioTransfer');
                            this.wasRecentlySpeaking = true;
                        };
                        reader.readAsDataURL(combinedBlob);
                    }
                } catch (error) {
                    console.error('üö® Error sending buffered audio:', error);
                    this.endTiming('audioCapture');
                    this.endTiming('audioTransfer');
                }
                
                // Clear the buffer
                this.audioBuffer = [];
                this.bufferStartTime = 0;
                console.log('üéµ Audio buffer cleared');
            }

            handleWebSocketMessage(data) {
                // üîç COMPREHENSIVE TIMING: Track all server response delays
                const serverResponseTime = performance.now();
                const messageReceived = Date.now();
                
                // üîç TIMING: Calculate network latency if we have transmission timestamps
                if (data.server_received_at && this.timingEnhancements.lastSendTime) {
                    const networkLatency = data.server_received_at - this.timingEnhancements.lastSendTime;
                    this.timingEnhancements.networkLatency = networkLatency;
                    console.log(`üåê Network latency: ${networkLatency}ms`);
                }
                
                // üîç TIMING: Track server processing queue depth
                if (data.queue_info) {
                    this.timingEnhancements.serverQueueDepth = data.queue_info.depth || 0;
                    this.timingEnhancements.queueTime = data.queue_info.wait_time || 0;
                    console.log(`üìã Server queue: ${this.timingEnhancements.serverQueueDepth} items, ${this.timingEnhancements.queueTime}ms wait`);
                }
                
                switch (data.type) {
                    case 'process_status':
                        // Handle process status updates
                        if (data.stage && data.status) {
                            this.setStageStatus(data.stage, data.status, data.details);
                        }
                        break;
                        
                    case 'processing_started':
                        // Enhanced: Handle LLM processing start notification
                        this.updateMicrophoneStatus('processing', 'AI is processing your request...');
                        console.log('ü§ñ LLM processing started');
                        break;
                        
                    case 'llm_completed':
                        // Enhanced: Handle LLM completion notification
                        this.updateMicrophoneStatus('processing', 'Generating audio...');
                        if (data.text_preview) {
                            console.log('‚úÖ LLM completed, preview:', data.text_preview);
                        }
                        break;
                        
                    case 'tts_started':
                        // Enhanced: Handle TTS start notification
                        this.updateMicrophoneStatus('processing', 'Converting text to speech...');
                        console.log('üîä TTS processing started');
                        break;
                        
                    case 'tts_completed':
                        // Enhanced: Handle TTS completion notification
                        this.updateMicrophoneStatus('processing', 'Audio ready, playing...');
                        console.log('‚úÖ TTS completed, audio ready');
                        break;
                        
                    case 'preflight_test':
                        // Enhanced: Handle pre-flight connection test
                        console.log('‚úÖ Pre-flight connection test received');
                        break;
                        
                    case 'audio_chunk':
                        // Enhanced: Handle chunked audio delivery
                        this.handleAudioChunk(data);
                        break;
                        
                    case 'transcription':
                        // üîç TIMING: STT processing complete
                        this.endTiming('sttProcessing');
                        this.startTiming('llmProcessing');
                        
                        // EMERGENCY INTERRUPT: Check for emergency keywords in WebSocket transcription
                        if (data.text && this.checkEmergencyInterrupt(data.text)) {
                            console.log('üö® Emergency interrupt detected in WebSocket transcription, stopping processing');
                            return; // Stop all further processing
                        }
                        
                        this.completeSpeechRecognition(data.text);
                        this.completeTransfer();
                        this.addMessage('user', data.text);
                        this.showLoading(true);
                        
                        // Temporarily pause audio visualization during processing
                        this.updateMicrophoneStatus('processing', 'Processing speech...');
                        
                        // üîç TIMING: Start STT processing timing
                        this.startTiming('sttProcessing');
                        
                        if (data.processing_time) {
                            console.log(`‚è±Ô∏è Server STT processing time: ${data.processing_time.toFixed(2)}s`);
                        }
                        break;
                        
                    case 'ai_response':
                        // üîç TIMING: Complete AI processing with server timing data
                        this.endTiming('llmProcessing');
                        this.endTiming('ttsGeneration');
                        
                        // üéØ INTEGRATE SERVER TIMING: Replace client estimates with actual server data
                        if (data.timing) {
                            // Override client timings with actual server processing times
                            this.performanceProfiler.setServerTiming('llmProcessing', data.timing.llm_time * 1000);
                            this.performanceProfiler.setServerTiming('ttsGeneration', data.timing.tts_time * 1000);
                            
                            console.log(`‚è±Ô∏è Server processing times integrated:`, data.timing);
                            
                            // Display accurate server timing in performance profiler
                            this.performanceProfiler.displayRealTimeStats();
                        }
                        
                        // üåê CONNECTION SUCCESS: Reset reconnection attempts on successful response
                        this.reconnectionAttempts = 0;
                        console.log('‚úÖ Audio response received successfully - WebSocket connection stable');
                        
                        this.completeLLMProcessing();
                        this.completeTTSProcessing();
                        this.showLoading(false);
                        this.addMessage('ai', data.text);
                        
                        // Resume normal microphone status
                        this.updateMicrophoneStatus('idle', 'Listening...');
                        
                        if (data.audio) {
                            // üîç TIMING: Start audio playback (client-side timing)
                            this.startTiming('audioPlayback');
                            this.playAudioResponse(data.audio);
                        } else {
                            // No audio received - possible WebSocket issue
                            this.addMessage('system', '‚ö†Ô∏è <span style="color: orange;">Text response received but no audio - possible connection issue</span>');
                        }
                        break;
                        
                    case 'ai_message':
                        // Phase 3: Handle AI messages (like kid-friendly greetings)
                        this.addMessage('ai', data.message);
                        break;
                        
                    case 'background_music':
                        if (this.getCallSettings().background_music) {
                            this.playBackgroundMusic(data.audio, data.volume || 0.3);
                        }
                        break;
                        
                    case 'interrupt':
                    case 'interrupt_confirmed':
                        // Enhanced interrupt handling for both manual and auto interrupts
                        this.stopCurrentAudio();
                        this.stopBackgroundMusic();
                        this.showLoading(false);
                        
                        // Show different messages for different interrupt types
                        let interruptMessage = data.message || 'AI interrupted';
                        if (data.interrupt_type === 'auto_interrupt') {
                            interruptMessage = data.message || 'AI paused for you to speak';
                            this.addMessage('system', 'ü§ñ ' + interruptMessage);
                        } else {
                            this.addMessage('system', '‚è∏Ô∏è ' + interruptMessage);
                        }
                        
                        this.updateStatus('success', interruptMessage);
                        this.resetProcessStages();
                        break;
                        
                    case 'session_ended':
                        // Phase 3: Handle enhanced session end with summary
                        this.showLoading(false);
                        this.hideProcessStatus();
                        if (data.call_summary) {
                            this.addMessage('system', 
                                `Call ended. Duration: ${data.call_summary.duration}, Messages: ${data.call_summary.messages_exchanged}`
                            );
                        }
                        this.updateStatus('success', data.message);
                        break;
                        
                    case 'error':
                        this.showLoading(false);
                        // Handle process errors based on context
                        if (data.stage) {
                            this.handleProcessError(data.stage, data.message);
                        } else {
                            this.resetProcessStages();
                        }
                        this.addMessage('system', 'Error: ' + data.message);
                        break;
                        
                    case 'status':
                        this.updateStatus('info', data.message);
                        // Phase 3: Handle kid-friendly mode confirmation
                        if (data.kid_friendly_mode !== undefined) {
                            const toggle = document.getElementById('kidFriendlyToggle');
                            if (toggle) {
                                toggle.checked = data.kid_friendly_mode;
                            }
                            if (data.kid_friendly_mode) {
                                this.addMessage('system', 'üë∂ Kid-friendly mode enabled');
                            }
                        }
                        break;
                        
                    case 'heartbeat':
                    case 'ping':
                        // Handle server heartbeat/ping messages to maintain connection
                        console.log('üíì Received heartbeat from server');
                        // Optionally respond with pong if needed
                        break;
                }
            }

            // Enhanced: Handle chunked audio delivery
            handleAudioChunk(data) {
                console.log(`üîç DEBUG: handleAudioChunk called with:`, data);
                
                if (!this.audioChunks) {
                    this.audioChunks = [];
                    console.log(`üîç DEBUG: Initialized audioChunks array`);
                }
                
                // Validate chunk data
                if (typeof data.chunk_index !== 'number' || typeof data.total_chunks !== 'number') {
                    console.error(`‚ùå Invalid chunk data: chunk_index=${data.chunk_index}, total_chunks=${data.total_chunks}`);
                    return;
                }
                
                if (!data.audio_chunk) {
                    console.error(`‚ùå No audio_chunk data in chunk ${data.chunk_index}`);
                    return;
                }
                
                // Store the chunk
                this.audioChunks[data.chunk_index] = data.audio_chunk;
                
                console.log(`üì¶ Received audio chunk ${data.chunk_index + 1}/${data.total_chunks} (${data.audio_chunk ? data.audio_chunk.length : 0} chars)`);
                console.log(`üîç DEBUG: Current chunks array length: ${this.audioChunks.length}, expected: ${data.total_chunks}`);
                
                // Check how many chunks we have
                const receivedChunks = this.audioChunks.filter(chunk => chunk !== undefined).length;
                console.log(`üîç DEBUG: Received ${receivedChunks}/${data.total_chunks} chunks`);
                
                // If we have all chunks, combine and play
                if (receivedChunks === data.total_chunks) {
                    console.log(`üéµ All chunks received! Combining audio...`);
                    
                    // Validate all chunks before combining
                    const missingChunks = [];
                    for (let i = 0; i < data.total_chunks; i++) {
                        if (!this.audioChunks[i]) {
                            missingChunks.push(i);
                        }
                    }
                    
                    if (missingChunks.length > 0) {
                        console.error(`‚ùå Missing chunks: ${missingChunks.join(', ')}`);
                        return;
                    }
                    
                    const completeAudio = this.audioChunks.join('');
                    console.log(`üéµ Complete audio assembled: ${completeAudio.length} chars`);
                    
                    // Validate the complete audio is valid base64
                    try {
                        const binaryData = atob(completeAudio);
                        console.log(`‚úÖ Audio base64 is valid: ${binaryData.length} bytes decoded`);
                        
                        // Check if it looks like audio data (basic validation)
                        if (binaryData.length < 44) {
                            console.warn(`‚ö†Ô∏è Audio data seems too small: ${binaryData.length} bytes`);
                        }
                        
                    } catch (e) {
                        console.error(`‚ùå Invalid base64 audio data: ${e.message}`);
                        this.addMessage('system', '‚ùå <span style="color: red;">Invalid audio data received</span>');
                        return;
                    }
                    
                    // Play the complete audio
                    console.log(`üéµ Calling playAudioResponse...`);
                    this.playAudioResponse(completeAudio);
                    
                    // Add text message if provided
                    if (data.text) {
                        console.log(`üìù Adding AI message: ${data.text}`);
                        this.addMessage('ai', data.text);
                    }
                    
                    // Handle timing data if provided
                    if (data.timing) {
                        this.performanceProfiler.setServerTiming('llmProcessing', data.timing.llm_time * 1000);
                        this.performanceProfiler.setServerTiming('ttsGeneration', data.timing.tts_time * 1000);
                        this.performanceProfiler.displayRealTimeStats();
                    }
                    
                    // Reset for next audio
                    this.audioChunks = [];
                    this.showLoading(false);
                    this.updateMicrophoneStatus('idle', 'Listening...');
                    
                    console.log(`‚úÖ Audio chunk processing complete`);
                } else {
                    console.log(`‚è≥ Still waiting for more chunks: ${receivedChunks}/${data.total_chunks}`);
                }
            }

            playAudioResponse(audioBase64) {
                console.log(`üéµ DEBUG: playAudioResponse called with ${audioBase64 ? audioBase64.length : 0} chars`);
                try {
                    if (!audioBase64) {
                        console.error('‚ùå No audio data received');
                        this.addMessage('system', '‚ùå <span style="color: red;">No audio data - WebSocket connection issue</span>');
                        return;
                    }
                    
                    console.log(`üéµ DEBUG: Audio data validated, proceeding with playback...`);
                    
                    // Validate base64 format
                    if (typeof audioBase64 !== 'string') {
                        console.error('‚ùå Audio data is not a string:', typeof audioBase64);
                        this.addMessage('system', '‚ùå <span style="color: red;">Invalid audio data format</span>');
                        return;
                    }
                    
                    // Test base64 decoding
                    try {
                        const testDecode = atob(audioBase64.substring(0, Math.min(100, audioBase64.length)));
                        console.log(`‚úÖ Base64 validation passed, sample: ${testDecode.length} bytes`);
                    } catch (e) {
                        console.error('‚ùå Base64 decoding failed:', e.message);
                        this.addMessage('system', '‚ùå <span style="color: red;">Invalid base64 audio data</span>');
                        return;
                    }
                    
                    // üö® OVERLAP DETECTION: Check if audio is already playing
                    const now = Date.now();
                    const timeSinceLastAudio = now - this.lastAudioStartTime;
                    
                    // If another audio started within last 2 seconds, it's likely an overlap
                    if (this.currentAudio && !this.currentAudio.paused && timeSinceLastAudio < 2000) {
                        console.log('üö® OVERLAP DETECTED: Stopping previous audio before playing new one');
                        this.addMessage('system', 'üö® Overlap detected - stopping previous AI response');
                        this.stopCurrentAudio();
                        this.audioOverlapDetected = true;
                    }
                    
                    // Stop any existing background music
                    this.stopBackgroundMusic();
                    
                    console.log(`üîä Creating audio element from ${audioBase64.length} bytes of base64 data`);
                    const audio = new Audio('data:audio/wav;base64,' + audioBase64);
                    audio.volume = 1.0; // Full volume for AI response
                    
                    // üö® ENHANCED ERROR HANDLING - Single error handler
                    audio.onerror = (error) => {
                        console.error('üö® Audio playback error:', error);
                        console.error('üö® Audio error details:', {
                            error: error,
                            src: audio.src ? audio.src.substring(0, 100) + '...' : 'no src',
                            networkState: audio.networkState,
                            readyState: audio.readyState
                        });
                        this.addMessage('system', 'üö® <span style="color: red;">Audio playback failed - check browser console for details</span>');
                        this.activeAudioElements.delete(audio);
                    };
                    
                    audio.onloadstart = () => {
                        console.log('üéµ Audio loading started');
                    };
                    
                    audio.oncanplaythrough = () => {
                        console.log('‚úÖ Audio ready to play');
                        this.addMessage('system', 'üîä <span style="color: blue;">AI audio ready</span>');
                    };
                    
                    audio.onloadeddata = () => {
                        console.log('üìä Audio data loaded:', {
                            duration: audio.duration,
                            networkState: audio.networkState,
                            readyState: audio.readyState
                        });
                    };
                    
                    // üö® OVERLAP PREVENTION: Track this audio element
                    this.activeAudioElements.add(audio);
                    this.lastAudioStartTime = now;
                    
                    audio.play().then(() => {
                        console.log('‚úÖ Audio playback started successfully');
                        this.addMessage('system', 'üéµ <span style="color: green;">Audio playing...</span>');
                    }).catch(error => {
                        console.error('‚ùå Failed to play AI audio response:', error);
                        console.error('‚ùå Play error details:', {
                            name: error.name,
                            message: error.message,
                            code: error.code
                        });
                        this.addMessage('system', '‚ùå <span style="color: red;">Audio playback failed - check browser permissions</span>');
                        this.activeAudioElements.delete(audio);
                    });
                    
                    // Track current audio for interrupt functionality
                    this.currentAudio = audio;
                    
                    audio.onended = () => {
                        // üîç TIMING: Audio playback complete, end full cycle
                        this.endTiming('audioPlayback');
                        this.endTiming('endToEnd');
                        
                        this.currentAudio = null;
                        this.activeAudioElements.delete(audio);
                        console.log('üéµ Audio playback completed normally');
                        
                        // üîç DISPLAY COMPLETE CYCLE PERFORMANCE
                        this.displayPerformanceSummary();
                    };
                    
                } catch (error) {
                    console.error('Error creating audio element:', error);
                }
            }
            
            // DEBUG: Test audio chunk functionality
            testAudioChunks() {
                console.log('üß™ Starting audio chunk test...');
                
                // Simulate receiving audio chunks
                const testChunks = [
                    'UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=', // Basic WAV header
                    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==', // Silent audio data
                    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==' // More silent audio data
                ];
                
                // Reset chunks array
                this.audioChunks = [];
                
                // Simulate chunk delivery
                testChunks.forEach((chunk, index) => {
                    setTimeout(() => {
                        const chunkData = {
                            type: 'audio_chunk',
                            chunk_index: index,
                            total_chunks: testChunks.length,
                            audio_chunk: chunk,
                            text: 'Test audio response'
                        };
                        
                        console.log(`üß™ Simulating chunk ${index + 1}/${testChunks.length}`);
                        this.handleAudioChunk(chunkData);
                    }, index * 500); // Delay each chunk by 500ms
                });
            }
            
            // DEBUG: Show debugging information
            showDebugInfo() {
                const currentUrl = window.location.href;
                const wsUrl = currentUrl.replace('http', 'ws').replace('https', 'wss').replace('/web/phone-call.html', '/api/phone/stream');
                
                console.log('üîç DEBUGGING INFORMATION:');
                console.log('üì± Current URL:', currentUrl);
                console.log('üîå WebSocket URL:', wsUrl);
                console.log('üåê Protocol:', window.location.protocol);
                console.log('üè† Host:', window.location.host);
                console.log('');
                console.log('üß™ Available debug functions:');
                console.log('  testAudioChunks() - Test chunked audio delivery');
                console.log('  console.clear()   - Clear console');
                console.log('  window.phoneCallManager - Access manager object');
                
                // Show current state
                if (this.websocket) {
                    console.log('üîå WebSocket state:', this.websocket.readyState);
                    console.log('   0 = CONNECTING, 1 = OPEN, 2 = CLOSING, 3 = CLOSED');
                }
                
                alert('Debug info logged to console! Open Developer Tools (F12) ‚Üí Console tab');
            }

            playBackgroundMusic(audioBase64, volume = 0.3) {
                try {
                    // Stop any existing background music
                    this.stopBackgroundMusic();
                    
                    const audio = new Audio('data:audio/wav;base64,' + audioBase64);
                    audio.volume = volume;
                    audio.loop = true; // Loop background music
                    
                    audio.play().catch(error => {
                        console.log('Background music playback failed (this is normal):', error);
                    });
                    
                    this.backgroundAudio = audio;
                } catch (error) {
                    console.log('Background music error (this is normal):', error);
                }
            }

            stopBackgroundMusic() {
                if (this.backgroundAudio) {
                    this.backgroundAudio.pause();
                    this.backgroundAudio.currentTime = 0;
                    this.backgroundAudio = null;
                }
            }

            // Phase 3: Stop current AI audio (for interrupts)
            stopCurrentAudio() {
                // üö® ENHANCED: Stop ALL active audio elements to prevent overlap
                console.log(`üö® IMMEDIATE AUDIO STOP - Found ${this.activeAudioElements.size} active elements`);
                
                // Stop current primary audio IMMEDIATELY
                if (this.currentAudio) {
                    try {
                        this.currentAudio.pause();
                        this.currentAudio.currentTime = 0;
                        this.currentAudio = null;
                        console.log('üö® Primary audio stopped immediately');
                    } catch (error) {
                        console.error('Error stopping primary audio:', error);
                    }
                }
                
                // Stop ALL tracked audio elements (catches any overlapping audio)
                this.activeAudioElements.forEach(audio => {
                    try {
                        if (!audio.paused) {
                            console.log('üö® Stopping overlapping audio element');
                            audio.pause();
                            audio.currentTime = 0;
                        }
                    } catch (error) {
                        console.error('Error stopping audio element:', error);
                    }
                });
                
                // üéØ NUCLEAR OPTION: Stop ALL audio elements in the entire page
                const allAudioElements = document.querySelectorAll('audio');
                allAudioElements.forEach(audio => {
                    try {
                        if (!audio.paused) {
                            console.log('üö® NUCLEAR: Stopping any remaining audio element');
                            audio.pause();
                            audio.currentTime = 0;
                        }
                    } catch (error) {
                        console.error('Error stopping page audio element:', error);
                    }
                });
                
                // Clear the active audio set
                this.activeAudioElements.clear();
                console.log('üö® ALL AUDIO ELEMENTS STOPPED AND CLEARED - SILENCE ACHIEVED');
            }
            
            handleWebSocketReconnection() {
                if (this.reconnectionAttempts >= this.maxReconnectionAttempts) {
                    console.log('üö® Max reconnection attempts reached, stopping');
                    this.addMessage('system', '‚ùå <span style="color: red;">Connection lost and could not be restored</span>');
                    return;
                }
                
                this.reconnectionAttempts++;
                console.log(`üîÑ Attempting WebSocket reconnection #${this.reconnectionAttempts}...`);
                this.addMessage('system', `üîÑ Connection lost, attempting to reconnect... (${this.reconnectionAttempts}/${this.maxReconnectionAttempts})`);
                
                // Close existing connection if any
                if (this.websocket) {
                    this.websocket.close();
                }
                
                // Wait a moment then reconnect
                setTimeout(() => {
                    this.initializeWebSocket();
                }, 1000 * this.reconnectionAttempts); // Exponential backoff
            }

            endCall() {
                this.updateCallState('ended');
                
                // üö® IMMEDIATE AUDIO STOP ON HANGUP - TOP PRIORITY
                console.log('üö® HANGUP DETECTED - STOPPING ALL AUDIO IMMEDIATELY');
                this.stopCurrentAudio();
                this.stopBackgroundMusic();
                
                // üö® STOP OVERLAP DETECTION
                this.stopOverlapDetection();
                console.log('üö® Overlap detection stopped for ended call');
                
                // üéØ CLEAR AUDIO BUFFER
                if (this.audioBuffer.length > 0) {
                    console.log(`üéµ Clearing ${this.audioBuffer.length} buffered audio chunks on call end`);
                    this.audioBuffer = [];
                    this.bufferStartTime = 0;
                }
                
                // Hide process status and audio visualizer
                this.hideProcessStatus();
                this.hideAudioVisualizer();
                
                // Clean up resources
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop();
                }
                
                if (this.recordingInterval) {
                    clearInterval(this.recordingInterval);
                }
                
                // Close audio context
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                if (this.websocket) {
                    this.websocket.send(JSON.stringify({
                        type: 'session_end',
                        session_id: this.currentSessionId
                    }));
                    this.websocket.close();
                }
                
                this.stopCallTimer();
                
                // Reset UI after a delay
                setTimeout(() => {
                    this.updateCallState('idle');
                    this.conversationDisplay.style.display = 'none';
                    this.conversationMessages.innerHTML = '';
                }, 3000);
                
                this.saveCallToHistory();
            }

            interruptAI() {
                // Stop current AI audio playback
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.currentTime = 0;
                    this.currentAudio = null;
                }
                
                // Stop background music
                this.stopBackgroundMusic();
                
                // Send interrupt signal to server
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify({
                        type: 'interrupt',
                        session_id: this.currentSessionId
                    }));
                }
                
                this.showLoading(false);
                this.addMessage('system', 'AI interrupted by user');
            }

            updateCallState(newState) {
                this.callState = newState;
                
                // Update button states
                this.dialButton.disabled = newState !== 'idle';
                this.hangupButton.disabled = newState === 'idle';
                this.interruptButton.disabled = newState !== 'connected';
                
                // Update status display
                this.callStatus.className = `call-status status-${newState}`;
                
                switch (newState) {
                    case 'idle':
                        this.updateStatus('info', 'Ready to dial', 'Click the dial button to start your call');
                        break;
                    case 'dialing':
                        this.updateStatus('warning', 'Dialing...', 'Connecting to AI assistant');
                        break;
                    case 'connected':
                        this.updateStatus('success', 'Connected', 'Call in progress');
                        break;
                    case 'ended':
                        this.updateStatus('info', 'Call ended', 'Thank you for calling!');
                        break;
                }
            }

            updateStatus(type, text, details = '') {
                this.statusText.textContent = text;
                this.statusDetails.textContent = details;
            }

            addMessage(type, text) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}-message`;
                
                const timestamp = new Date().toLocaleTimeString();
                const prefix = type === 'user' ? 'You' : type === 'ai' ? 'AI' : 'System';
                
                messageDiv.innerHTML = `<strong>${prefix} (${timestamp}):</strong> ${text}`;
                this.conversationMessages.appendChild(messageDiv);
                this.conversationMessages.scrollTop = this.conversationMessages.scrollHeight;
            }

            showLoading(show) {
                this.loadingIndicator.style.display = show ? 'block' : 'none';
            }

            startCallTimer() {
                this.callStartTime = Date.now();
                this.callTimer = setInterval(() => {
                    const elapsed = Date.now() - this.callStartTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    this.callTimerDisplay.textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
                
                // Start WebSocket heartbeat to prevent disconnections
                this.startHeartbeat();
            }

            stopCallTimer() {
                if (this.callTimer) {
                    clearInterval(this.callTimer);
                    this.callTimer = null;
                }
                
                // Stop WebSocket heartbeat
                this.stopHeartbeat();
            }
            
            startHeartbeat() {
                // Enhanced aggressive heartbeat with connection monitoring
                this.heartbeatInterval = setInterval(() => {
                    if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                        this.websocket.send(JSON.stringify({
                            type: 'ping',
                            session_id: this.currentSessionId,
                            timestamp: Date.now()
                        }));
                        console.log('üíì Client heartbeat sent');
                    } else if (this.websocket) {
                        console.log('üö® WebSocket not open during heartbeat, state:', this.websocket.readyState);
                        this.handleWebSocketReconnection();
                    }
                }, 3000); // Aggressive 3-second heartbeat
                
                // Additional connection monitor for critical operations
                this.connectionMonitor = setInterval(() => {
                    if (this.websocket && this.websocket.readyState !== WebSocket.OPEN) {
                        console.log('‚ö†Ô∏è Connection monitor detected disconnection, attempting recovery...');
                        this.handleWebSocketReconnection();
                    }
                }, 1000); // Check every 1 second during active calls
            }
            
            stopHeartbeat() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                    this.heartbeatInterval = null;
                }
                if (this.connectionMonitor) {
                    clearInterval(this.connectionMonitor);
                    this.connectionMonitor = null;
                }
            }

            getCallSettings() {
                // Ensure all values have proper defaults
                const speed = parseFloat(this.speedSelect.value);
                return {
                    language: this.languageSelect.value || 'en',
                    model: this.modelSelect.value || 'gemma2:2b',
                    speed: isNaN(speed) ? 1.0 : speed,
                    kid_friendly: Boolean(this.kidFriendlyToggle.checked),
                    background_music: Boolean(this.backgroundMusicToggle.checked)
                };
            }

            updateSettings() {
                // Save settings to localStorage
                localStorage.setItem('phoneCallSettings', JSON.stringify(this.getCallSettings()));
                
                // If call is active, send settings update
                if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
                    this.websocket.send(JSON.stringify({
                        type: 'settings_update',
                        session_id: this.currentSessionId,
                        settings: this.getCallSettings()
                    }));
                }
            }

            generateSessionId() {
                return 'phone-call-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            }

            saveCallToHistory() {
                const callDuration = this.callTimerDisplay.textContent;
                const historyItem = {
                    timestamp: new Date().toISOString(),
                    duration: callDuration,
                    settings: this.getCallSettings()
                };
                
                // Save to localStorage (in real app, this would go to backend)
                const history = JSON.parse(localStorage.getItem('callHistory') || '[]');
                history.unshift(historyItem);
                history.splice(10); // Keep only last 10 calls
                localStorage.setItem('callHistory', JSON.stringify(history));
                
                this.updateCallHistoryDisplay();
            }

            // üö® EMERGENCY: Toggle noise gate on/off
            toggleNoiseGate() {
                this.noiseGate.bypassMode = !this.noiseGate.bypassMode;
                this.noiseGate.enabled = !this.noiseGate.bypassMode;
                this.noiseGate.isRecordingValid = this.noiseGate.bypassMode;
                
                // Update button appearance
                if (this.noiseGate.bypassMode) {
                    this.noiseGateButton.style.background = '#dc3545'; // Red - bypassed
                    this.noiseGateButton.textContent = 'üîá';
                    this.noiseGateButton.title = 'Noise Gate: BYPASSED (click to enable)';
                    this.addMessage('system', 'üö® <span style="color: red;">Noise Gate BYPASSED</span> - All audio will be processed');
                } else {
                    this.noiseGateButton.style.background = '#28a745'; // Green - active
                    this.noiseGateButton.textContent = 'üîä';
                    this.noiseGateButton.title = 'Noise Gate: ACTIVE (click to bypass)';
                    this.addMessage('system', 'üîä <span style="color: green;">Noise Gate ACTIVE</span> - Background noise will be filtered');
                    
                    // Reset calibration when enabling
                    this.noiseGate.calibrated = false;
                    this.noiseGate.calibrationSamples = [];
                    this.noiseGate.isRecordingValid = false;
                }
                
                console.log(`üîä Noise gate toggled: ${this.noiseGate.bypassMode ? 'BYPASSED' : 'ACTIVE'}`);
            }

            updateCallHistoryDisplay() {
                const history = JSON.parse(localStorage.getItem('callHistory') || '[]');
                const historyList = document.getElementById('callHistoryList');
                
                historyList.innerHTML = history.map(call => `
                    <div class="history-item">
                        <div class="history-time">${new Date(call.timestamp).toLocaleString()}</div>
                        <div class="history-duration">Duration: ${call.duration}</div>
                    </div>
                `).join('');
            }

            loadSettings() {
                const saved = localStorage.getItem('phoneCallSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    this.languageSelect.value = settings.language || 'en';
                    this.modelSelect.value = settings.model || 'gemma2:2b';
                    this.speedSelect.value = settings.speed || 1.0;
                    this.kidFriendlyToggle.checked = settings.kid_friendly || false;
                    this.backgroundMusicToggle.checked = settings.background_music !== false;
                }
            }
        }

        // Initialize the phone call interface when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const phoneInterface = new PhoneCallInterface();
            phoneInterface.loadSettings();
            phoneInterface.updateCallHistoryDisplay();
            
            // DEBUG: Expose test function globally
            window.testAudioChunks = () => phoneInterface.testAudioChunks();
            window.showDebugInfo = () => phoneInterface.showDebugInfo();
            console.log('üß™ DEBUG: Debug functions available:');
            console.log('  testAudioChunks() - Test chunked audio delivery');
            console.log('  showDebugInfo()   - Show debug information');
        });
    </script>
</body>
</html>
